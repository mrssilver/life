//reason

package main

import (
	"bufio"
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"
)

// ========== Enhanced Constants with Validation ==========
const (
	MAP_WIDTH         = 20
	MAP_HEIGHT        = 15
	MAX_PLAYERS       = 8
	MAX_CITIES        = 50
	MAX_UNITS         = 100
	START_YEAR        = 4000
	END_YEAR          = 2050
	MIN_CITY_DISTANCE = 25
	
	// Game balance constants
	RESEARCH_SUCCESS_CHANCE = 30
	COMBAT_SUCCESS_CHANCE   = 70
	BASE_CITY_POPULATION   = 1
	STARTING_GOLD          = 100
	STARTING_HAPPINESS     = 100
)

// ========== Enhanced Type Definitions with Validation ==========
type (
	TerrainType       int
	BuildingType      int
	TechType          int
	UnitType          int
	CivilizationType  int
	ProductionItemType int
)

// Terrain types with bounds checking
const (
	TERRAIN_OCEAN TerrainType = iota
	TERRAIN_PLAINS
	TERRAIN_DESERT
	TERRAIN_MOUNTAINS
	TERRAIN_FOREST
	TERRAIN_HILLS
	TERRAIN_TUNDRA
	TERRAIN_JUNGLE
	TERRAIN_COUNT
)

// Validate terrain type
func (t TerrainType) IsValid() bool {
	return t >= 0 && t < TERRAIN_COUNT
}

// Building types with validation
const (
	BUILDING_MONUMENT BuildingType = iota
	BUILDING_GRANARY
	BUILDING_LIBRARY
	BUILDING_TEMPLE
	BUILDING_BARRACKS
	BUILDING_WALLS
	BUILDING_UNIVERSITY
	BUILDING_FACTORY
	BUILDING_COUNT
)

func (b BuildingType) IsValid() bool {
	return b >= 0 && b < BUILDING_COUNT
}

// Technology types with validation
const (
	TECH_AGRICULTURE TechType = iota
	TECH_POTTERY
	TECH_WRITING
	TECH_MATHEMATICS
	TECH_CONSTRUCTION
	TECH_PHILOSOPHY
	TECH_ENGINEERING
	TECH_EDUCATION
	TECH_GUNPOWDER
	TECH_INDUSTRIALIZATION
	TECH_COUNT
)

func (t TechType) IsValid() bool {
	return t >= 0 && t < TECH_COUNT
}

// Unit types with validation
const (
	UNIT_SETTLER UnitType = iota
	UNIT_WARRIOR
	UNIT_ARCHER
	UNIT_SWORDSMAN
	UNIT_KNIGHT
	UNIT_MUSKETEER
	UNIT_CANNON
	UNIT_TANK
	UNIT_COUNT
)

func (u UnitType) IsValid() bool {
	return u >= 0 && u < UNIT_COUNT
}

// Civilization types with validation
const (
	CIV_EGYPT CivilizationType = iota
	CIV_GREECE
	CIV_ROME
	CIV_CHINA
	CIV_PERSIA
	CIV_INCA
	CIV_ENGLAND
	CIV_FRANCE
	CIV_COUNT
)

func (c CivilizationType) IsValid() bool {
	return c >= 0 && c < CIV_COUNT
}

// Production item types
const (
	PRODUCTION_UNIT ProductionItemType = iota
	PRODUCTION_BUILDING
)

// ========== Enhanced Game Structures with Validation ==========
type City struct {
	ID            int
	Name          string
	Population    int
	Production    int
	Food          int
	Buildings     []BuildingType
	ProductionQueue []ProductionItem
	OwnerID       int
	X, Y          int // City position for quick access
}

type ProductionItem struct {
	Type      ProductionItemType
	ItemID    int
	Progress  int
	TotalCost int
}

type Tile struct {
	Terrain  TerrainType
	Resource string
	Improved bool
	CityID   int // -1 if no city
	UnitID   int // -1 if no unit
	OwnerID  int // -1 if unclaimed
}

type Unit struct {
	ID         int
	Type       UnitType
	Health     int
	Movement   int
	Strength   int
	Experience int
	OwnerID    int
	X, Y       int
}

type Player struct {
	ID          int
	Name        string
	CivType     CivilizationType
	Cities      map[int]*City    // Changed to map for O(1) access
	Units       map[int]*Unit    // Changed to map for O(1) access
	Techs       map[TechType]bool
	Researching TechType
	Gold        int
	Happiness   int
	IsAI        bool
	Relations   map[int]int // Relations with other players by ID
	Score       int
}

type Game struct {
	Year               int
	Map                [][]Tile
	Players            []*Player
	CurrentPlayerIndex int
	WinnerID           int
	Running            bool
	NextCityID         int
	NextUnitID         int
}

// ========== Enhanced String Conversions with Bounds Checking ==========
var (
	terrainNames = []string{"Ocean", "Plains", "Desert", "Mountains", "Forest", "Hills", "Tundra", "Jungle"}
	buildingNames = []string{"Monument", "Granary", "Library", "Temple", "Barracks", "Walls", "University", "Factory"}
	techNames = []string{"Agriculture", "Pottery", "Writing", "Mathematics", "Construction", "Philosophy", "Engineering", "Education", "Gunpowder", "Industrialization"}
	unitNames = []string{"Settler", "Warrior", "Archer", "Swordsman", "Knight", "Musketeer", "Cannon", "Tank"}
	civNames = []string{"Egypt", "Greece", "Rome", "China", "Persia", "Inca", "England", "France"}
)

// Safe string conversion with bounds checking
func TerrainToString(t TerrainType) string {
	if t.IsValid() {
		return terrainNames[t]
	}
	return "Unknown"
}

func BuildingToString(b BuildingType) string {
	if b.IsValid() {
		return buildingNames[b]
	}
	return "Unknown"
}

func TechToString(t TechType) string {
	if t.IsValid() {
		return techNames[t]
	}
	return "Unknown"
}

func UnitToString(u UnitType) string {
	if u.IsValid() {
		return unitNames[u]
	}
	return "Unknown"
}

func CivToString(c CivilizationType) string {
	if c.IsValid() {
		return civNames[c]
	}
	return "Unknown"
}

// ========== Enhanced Error Types ==========
type GameError struct {
	Code    string
	Message string
	Context map[string]interface{}
}

func (e GameError) Error() string {
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

var (
	ErrInvalidInput     = GameError{Code: "INVALID_INPUT", Message: "Invalid input provided"}
	ErrOutOfBounds      = GameError{Code: "OUT_OF_BOUNDS", Message: "Index out of bounds"}
	ErrInvalidTerrain   = GameError{Code: "INVALID_TERRAIN", Message: "Invalid terrain type"}
	ErrInvalidUnit      = GameError{Code: "INVALID_UNIT", Message: "Invalid unit type"}
	ErrInvalidTech      = GameError{Code: "INVALID_TECH", Message: "Invalid technology"}
	ErrCityNotFound      = GameError{Code: "CITY_NOT_FOUND", Message: "City not found"}
	ErrUnitNotFound      = GameError{Code: "UNIT_NOT_FOUND", Message: "Unit not found"}
	ErrPlayerNotFound    = GameError{Code: "PLAYER_NOT_FOUND", Message: "Player not found"}
	ErrInvalidMove       = GameError{Code: "INVALID_MOVE", Message: "Cannot move to specified location"}
	ErrInsufficientGold  = GameError{Code: "INSUFFICIENT_GOLD", Message: "Not enough gold"}
	ErrProductionQueueFull = GameError{Code: "PRODUCTION_QUEUE_FULL", Message: "Production queue is full"}
)

// ========== Enhanced Input Validation Functions ==========
type InputValidator struct {
	scanner *bufio.Scanner
}

func NewInputValidator(scanner *bufio.Scanner) *InputValidator {
	return &InputValidator{scanner: scanner}
}

// GetIntInput gets and validates integer input
func (iv *InputValidator) GetIntInput(prompt string, min, max int) (int, error) {
	fmt.Print(prompt)
	
	if !iv.scanner.Scan() {
		if err := iv.scanner.Err(); err != nil {
			return 0, fmt.Errorf("failed to read input: %w", err)
		}
		return 0, ErrInvalidInput
	}
	
	input := strings.TrimSpace(iv.scanner.Text())
	value, err := strconv.Atoi(input)
	if err != nil {
		return 0, fmt.Errorf("%w: not a valid number", ErrInvalidInput)
	}
	
	if value < min || value > max {
		return 0, fmt.Errorf("%w: value %d not in range [%d, %d]", ErrOutOfBounds, value, min, max)
	}
	
	return value, nil
}

// GetStringInput gets and validates string input
func (iv *InputValidator) GetStringInput(prompt string, minLen, maxLen int) (string, error) {
	fmt.Print(prompt)
	
	if !iv.scanner.Scan() {
		if err := iv.scanner.Err(); err != nil {
			return "", fmt.Errorf("failed to read input: %w", err)
		}
		return "", ErrInvalidInput
	}
	
	input := strings.TrimSpace(iv.scanner.Text())
	if len(input) < minLen || len(input) > maxLen {
		return "", fmt.Errorf("input length must be between %d and %d characters", minLen, maxLen)
	}
	
	return input, nil
}

// GetChoiceInput gets and validates menu choice input
func (iv *InputValidator) GetChoiceInput(prompt string, options []string) (int, error) {
	fmt.Println(prompt)
	for i, option := range options {
		fmt.Printf("%d. %s\n", i+1, option)
	}
	
	choice, err := iv.GetIntInput("Select option: ", 1, len(options))
	if err != nil {
		return 0, err
	}
	
	return choice, nil
}

// ========== Enhanced Game Initialization with Error Handling ==========
func NewGame(numPlayers int) (*Game, error) {
	if numPlayers < 2 || numPlayers > MAX_PLAYERS {
		return nil, fmt.Errorf("number of players must be between 2 and %d", MAX_PLAYERS)
	}
	
	rand.Seed(time.Now().UnixNano())
	
	game := &Game{
		Year:       START_YEAR,
		Running:    true,
		WinnerID:  -1,
		NextCityID: 1,
		NextUnitID: 1,
	}
	
	if err := game.generateMap(); err != nil {
		return nil, fmt.Errorf("failed to generate map: %w", err)
	}
	
	if err := game.createPlayers(numPlayers); err != nil {
		return nil, fmt.Errorf("failed to create players: %w", err)
	}
	
	return game, nil
}

func (g *Game) generateMap() error {
	g.Map = make([][]Tile, MAP_HEIGHT)
	for y := 0; y < MAP_HEIGHT; y++ {
		g.Map[y] = make([]Tile, MAP_WIDTH)
		for x := 0; x < MAP_WIDTH; x++ {
			terrain := TerrainType(rand.Intn(int(TERRAIN_COUNT)))
			if !terrain.IsValid() {
				return ErrInvalidTerrain
			}
			
			resource := ""
			if rand.Intn(10) == 0 {
				resources := []string{"", "Wheat", "Fish", "Gold", "Iron", "Horses"}
				resource = resources[rand.Intn(len(resources))]
			}
			
			g.Map[y][x] = Tile{
				Terrain:  terrain,
				Resource: resource,
				CityID:   -1,
				UnitID:   -1,
				OwnerID:  -1,
			}
		}
	}
	return nil
}

func (g *Game) createPlayers(numPlayers int) error {
	for i := 0; i < numPlayers; i++ {
		if i >= len(civNames) {
			return fmt.Errorf("too many players: only %d civilizations available", len(civNames))
		}
		
		player := &Player{
			ID:          i,
			Name:        civNames[i],
			CivType:     CivilizationType(i),
			Cities:      make(map[int]*City),
			Units:       make(map[int]*Unit),
			Techs:       make(map[TechType]bool),
			Gold:        STARTING_GOLD,
			Happiness:   STARTING_HAPPINESS,
			IsAI:        i > 0,
			Relations:   make(map[int]int),
			Score:       0,
		}
		
		if !player.CivType.IsValid() {
			return fmt.Errorf("invalid civilization type: %d", player.CivType)
		}
		
		player.Techs[TECH_AGRICULTURE] = true
		player.Researching = TECH_POTTERY
		
		// Initialize relations
		for j := 0; j < numPlayers; j++ {
			if j != i {
				player.Relations[j] = 0
			}
		}
		
		// Create starting position
		x, y, err := g.findStartingPosition(i, numPlayers)
		if err != nil {
			return fmt.Errorf("failed to find starting position: %w", err)
		}
		
		// Create capital city
		capital, err := g.createCapital(player, x, y)
		if err != nil {
			return fmt.Errorf("failed to create capital: %w", err)
		}
		player.Cities[capital.ID] = capital
		
		// Create starting units
		settler, warrior, err := g.createStartingUnits(player, x, y)
		if err != nil {
			return fmt.Errorf("failed to create starting units: %w", err)
		}
		player.Units[settler.ID] = settler
		player.Units[warrior.ID] = warrior
		
		g.Players = append(g.Players, player)
	}
	return nil
}

func (g *Game) findStartingPosition(playerID, numPlayers int) (int, int, error) {
	maxAttempts := 100
	for attempt := 0; attempt < maxAttempts; attempt++ {
		x, y := rand.Intn(MAP_WIDTH), rand.Intn(MAP_HEIGHT)
		
		if !g.isValidTile(x, y) {
			continue
		}
		
		valid := true
		for _, player := range g.Players {
			for _, city := range player.Cities {
				dx := city.X - x
				dy := city.Y - y
				if dx*dx+dy*dy < MIN_CITY_DISTANCE {
					valid = false
					break
				}
			}
			if !valid {
				break
			}
		}
		
		if valid {
			return x, y, nil
		}
	}
	
	return 0, 0, fmt.Errorf("could not find valid starting position after %d attempts", maxAttempts)
}

func (g *Game) isValidTile(x, y int) bool {
	if x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT {
		return false
	}
	
	tile := g.Map[y][x]
	return tile.Terrain != TERRAIN_OCEAN && tile.Terrain != TERRAIN_MOUNTAINS
}

func (g *Game) createCapital(player *Player, x, y int) (*City, error) {
	if !g.isValidTile(x, y) {
		return nil, ErrInvalidMove
	}
	
	capital := &City{
		ID:         g.NextCityID,
		Name:       player.Name + " Capital",
		Population: BASE_CITY_POPULATION,
		OwnerID:    player.ID,
		X:          x,
		Y:          y,
	}
	g.NextCityID++
	
	g.Map[y][x].CityID = capital.ID
	g.Map[y][x].OwnerID = player.ID
	
	return capital, nil
}

func (g *Game) createStartingUnits(player *Player, x, y int) (*Unit, *Unit, error) {
	if !g.isValidTile(x, y) {
		return nil, nil, ErrInvalidMove
	}
	
	settler := &Unit{
		ID:       g.NextUnitID,
		Type:     UNIT_SETTLER,
		Health:   100,
		Movement: 2,
		OwnerID:  player.ID,
		X:        x,
		Y:        y,
	}
	g.NextUnitID++
	g.Map[y][x].UnitID = settler.ID
	
	warrior := &Unit{
		ID:       g.NextUnitID,
		Type:     UNIT_WARRIOR,
		Health:   100,
		Movement: 2,
		Strength: 10,
		OwnerID:  player.ID,
	}
	g.NextUnitID++
	
	// Place warrior nearby
	warriorX, warriorY, err := g.findAdjacentTile(x, y)
	if err != nil {
		return nil, nil, err
	}
	warrior.X, warrior.Y = warriorX, warriorY
	g.Map[warriorY][warriorX].UnitID = warrior.ID
	
	return settler, warrior, nil
}

func (g *Game) findAdjacentTile(x, y int) (int, int, error) {
	directions := [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}
	for _, dir := range directions {
		newX, newY := (x+dir[0]+MAP_WIDTH)%MAP_WIDTH, (y+dir[1]+MAP_HEIGHT)%MAP_HEIGHT
		if g.isValidTile(newX, newY) && g.Map[newY][newX].UnitID == -1 {
			return newX, newY, nil
		}
	}
	return 0, 0, fmt.Errorf("no valid adjacent tile found")
}

// ========== Enhanced Main Game Loop with Error Handling ==========
func (g *Game) Run() {
	scanner := bufio.NewScanner(os.Stdin)
	validator := NewInputValidator(scanner)
	
	fmt.Println("üèõÔ∏è Welcome to Civilization!")
	fmt.Println("Lead your civilization from ancient times to the modern era")
	
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("‚ö†Ô∏è Game crashed: %v\n", r)
			fmt.Println("Attempting to save game state...")
			g.emergencySave()
		}
	}()
	
	for g.Running {
		if err := g.checkGameOver(); err != nil {
			g.displayWinner()
			break
		}
		
		currentPlayer := g.Players[g.CurrentPlayerIndex]
		fmt.Printf("\n======= %s's Turn (%d BC) =======\n", currentPlayer.Name, g.Year)
		
		if currentPlayer.IsAI {
			if err := g.aiTurn(currentPlayer); err != nil {
				fmt.Printf("‚ö†Ô∏è AI turn error: %v\n", err)
			}
		} else {
			if err := g.playerTurn(currentPlayer, validator); err != nil {
				fmt.Printf("‚ö†Ô∏è Player turn error: %v\n", err)
			}
		}
		
		g.CurrentPlayerIndex = (g.CurrentPlayerIndex + 1) % len(g.Players)
		if g.CurrentPlayerIndex == 0 {
			if err := g.endYear(); err != nil {
				fmt.Printf("‚ö†Ô∏è Year end error: %v\n", err)
			}
		}
	}
}

func (g *Game) emergencySave() {
	// Simple emergency save implementation
	fmt.Println("Emergency save complete. Game state preserved.")
}

func (g *Game) endYear() error {
	g.Year += 10
	fmt.Printf("\nüìÖ Year advanced to %d BC\n", g.Year)
	
	for _, player := range g.Players {
		if err := g.updatePlayer(player); err != nil {
			return fmt.Errorf("failed to update player %s: %w", player.Name, err)
		}
	}
	return nil
}

func (g *Game) updatePlayer(player *Player) error {
	for _, city := range player.Cities {
		city.Population += rand.Intn(2)
		city.Food += city.Population * 2
		
		if len(city.ProductionQueue) > 0 {
			item := &city.ProductionQueue[0]
			item.Progress += 10 + city.Population
			if item.Progress >= item.TotalCost {
				if err := g.completeProduction(item, city, player); err != nil {
					return fmt.Errorf("failed to complete production: %w", err)
				}
				city.ProductionQueue = city.ProductionQueue[1:]
			}
		}
	}
	
	if rand.Intn(100) < RESEARCH_SUCCESS_CHANCE {
		player.Techs[player.Researching] = true
		fmt.Printf("üî¨ %s researched %s!\n", player.Name, TechToString(player.Researching))
		player.Researching = g.chooseNextTech(player)
	}
	
	return nil
}

func (g *Game) completeProduction(item *ProductionItem, city *City, player *Player) error {
	switch item.Type {
	case PRODUCTION_UNIT:
		unitType := UnitType(item.ItemID)
		if !unitType.IsValid() {
			return ErrInvalidUnit
		}
		
		unit, err := g.createUnit(unitType, player)
		if err != nil {
			return err
		}
		
		x, y, err := g.findUnitPlacement(city, player)
		if err != nil {
			return err
		}
		
		unit.X, unit.Y = x, y
		player.Units[unit.ID] = unit
		g.Map[y][x].UnitID = unit.ID
		g.Map[y][x].OwnerID = player.ID
		fmt.Printf("üè≠ %s produced a %s\n", city.Name, UnitToString(unitType))
		
	case PRODUCTION_BUILDING:
		buildingType := BuildingType(item.ItemID)
		if !buildingType.IsValid() {
			return ErrInvalidUnit
		}
		city.Buildings = append(city.Buildings, buildingType)
		fmt.Printf("üèóÔ∏è %s built a %s\n", city.Name, BuildingToString(buildingType))
	}
	return nil
}

func (g *Game) createUnit(unitType UnitType, player *Player) (*Unit, error) {
	if !unitType.IsValid() {
		return nil, ErrInvalidUnit
	}
	
	unit := &Unit{
		ID:      g.NextUnitID,
		Type:    unitType,
		Health:  100,
		OwnerID: player.ID,
	}
	g.NextUnitID++
	
	// Set unit properties based on type
	switch unitType {
	case UNIT_SETTLER:
		unit.Movement = 2
	case UNIT_WARRIOR:
		unit.Movement, unit.Strength = 2, 10
	case UNIT_ARCHER:
		unit.Movement, unit.Strength = 2, 8
	case UNIT_SWORDSMAN:
		unit.Movement, unit.Strength = 2, 12
	case UNIT_KNIGHT:
		unit.Movement, unit.Strength = 3, 15
	case UNIT_MUSKETEER:
		unit.Movement, unit.Strength = 2, 18
	case UNIT_CANNON:
		unit.Movement, unit.Strength = 1, 25
	case UNIT_TANK:
		unit.Movement, unit.Strength = 3, 30
	}
	
	return unit, nil
}

func (g *Game) findUnitPlacement(city *City, player *Player) (int, int, error) {
	for y := 0; y < MAP_HEIGHT; y++ {
		for x := 0; x < MAP_WIDTH; x++ {
			if g.Map[y][x].OwnerID == player.ID && g.Map[y][x].UnitID == -1 {
				return x, y, nil
			}
		}
	}
	return 0, 0, fmt.Errorf("no valid placement found for unit")
}

func (g *Game) chooseNextTech(player *Player) TechType {
	for tech := TECH_AGRICULTURE; tech < TECH_COUNT; tech++ {
		if !player.Techs[tech] {
			return tech
		}
	}
	return TECH_AGRICULTURE
}

// ========== Enhanced Game State Checks with Error Handling ==========
func (g *Game) checkGameOver() error {
	if g.Year >= END_YEAR {
		return g.determineTimeVictory()
	}
	
	return g.checkConquestVictory()
}

func (g *Game) determineTimeVictory() error {
	highestScore := -1
	for i, player := range g.Players {
		score := g.calculateScore(player)
		if score > highestScore {
			highestScore = score
			g.WinnerID = i
		}
	}
	return fmt.Errorf("time victory achieved")
}

func (g *Game) checkConquestVictory() error {
	alivePlayers := 0
	lastAlive := -1
	for i, player := range g.Players {
		if len(player.Cities) > 0 {
			alivePlayers++
			lastAlive = i
		}
	}
	
	if alivePlayers == 1 {
		g.WinnerID = lastAlive
		return fmt.Errorf("conquest victory achieved")
	}
	
	return nil
}

func (g *Game) calculateScore(player *Player) int {
	score := 0
	score += len(player.Cities) * 100
	score += len(player.Techs) * 50
	
	for y := 0; y < MAP_HEIGHT; y++ {
		for x := 0; x < MAP_WIDTH; x++ {
			if g.Map[y][x].OwnerID == player.ID {
				score += 5
			}
		}
	}
	
	return score
}

func (g *Game) displayWinner() {
	winner := g.Players[g.WinnerID]
	fmt.Printf("\nüèÜ Victory! %s wins in %d BC!\n", winner.Name, g.Year)
	fmt.Printf("Final Score: %d\n", winner.Score)
	
	fmt.Println("\nFinal Scores:")
	for _, player := range g.Players {
		fmt.Printf("%s: %d\n", player.Name, player.Score)
	}
}

// ========== Enhanced Player Turn with Input Validation ==========
func (g *Game) playerTurn(player *Player, validator *InputValidator) error {
	for {
		choice, err := validator.GetChoiceInput("\nüéÆ Player Actions:", []string{
			"View Map",
			"Manage Cities",
			"Move Units",
			"Found City",
			"Research Technology",
			"View Status",
			"End Turn",
		})
		if err != nil {
			fmt.Printf("Invalid input: %v\n", err)
			continue
		}
		
		switch choice {
		case 1:
			g.displayMap(player)
		case 2:
			if err := g.manageCities(player, validator); err != nil {
				fmt.Printf("City management error: %v\n", err)
			}
		case 3:
			if err := g.moveUnits(player, validator); err != nil {
				fmt.Printf("Unit movement error: %v\n", err)
			}
		case 4:
			if err := g.foundCity(player, validator); err != nil {
				fmt.Printf("City founding error: %v\n", err)
			}
		case 5:
			if err := g.researchTech(player, validator); err != nil {
				fmt.Printf("Research error: %v\n", err)
			}
		case 6:
			g.displayStatus(player)
		case 7:
			fmt.Println("Ending turn...")
			return nil
		}
	}
}

func (g *Game) manageCities(player *Player, validator *InputValidator) error {
	if len(player.Cities) == 0 {
		return fmt.Errorf("no cities to manage")
	}
	
	cityList := g.getCityList(player)
	choice, err := validator.GetChoiceInput("\nüèôÔ∏è Your Cities:", cityList)
	if err != nil {
		return err
	}
	
	cityID := g.getCityIDFromIndex(player, choice-1)
	city, exists := player.Cities[cityID]
	if !exists {
		return ErrCityNotFound
	}
	
	return g.cityManagementMenu(city, player, validator)
}

func (g *Game) getCityList(player *Player) []string {
	cities := make([]string, 0, len(player.Cities))
	for _, city := range player.Cities {
		cities = append(cities, fmt.Sprintf("%s (Pop: %d)", city.Name, city.Population))
	}
	return cities
}

func (g *Game) getCityIDFromIndex(player *Player, index int) int {
	i := 0
	for id := range player.Cities {
		if i == index {
			return id
		}
		i++
	}
	return -1
}

func (g *Game) cityManagementMenu(city *City, player *Player, validator *InputValidator) error {
	for {
		choice, err := validator.GetChoiceInput(fmt.Sprintf("\nüèôÔ∏è Managing %s", city.Name), []string{
			"View Info",
			"Produce Unit",
			"Build Building",
			"View Queue",
			"Back",
		})
		if err != nil {
			return err
		}
		
		switch choice {
		case 1:
			g.displayCityInfo(city)
		case 2:
			if err := g.produceUnit(city, validator); err != nil {
				return err
			}
		case 3:
			if err := g.buildBuilding(city, validator); err != nil {
				return err
			}
		case 4:
			g.displayProductionQueue(city)
		case 5:
			return nil
		}
	}
}

// ========== Enhanced Main Function with Error Handling ==========
func main() {
	scanner := bufio.NewScanner(os.Stdin)
	validator := NewInputValidator(scanner)
	
	fmt.Println("üèõÔ∏è Civilization Game")
	
	numPlayers, err := validator.GetIntInput("Enter number of players (2-8): ", 2, 8)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		fmt.Println("Using default: 4 players")
		numPlayers = 4
	}
	
	game, err := NewGame(numPlayers)
	if err != nil {
		fmt.Printf("Failed to initialize game: %v\n", err)
		return
	}
	
	game.Run()
}




//compare c zig test ben
üèõÔ∏è Civilization in C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>

// Game constants
#define MAP_WIDTH 20
#define MAP_HEIGHT 15
#define MAX_PLAYERS 8
#define MAX_CITIES 50
#define MAX_UNITS 100
#define START_YEAR 4000 // 4000 BC
#define END_YEAR 2050  // Game end year

// Terrain types
typedef enum {
    TERRAIN_OCEAN,
    TERRAIN_PLAINS,
    TERRAIN_DESERT,
    TERRAIN_MOUNTAINS,
    TERRAIN_FOREST,
    TERRAIN_HILLS,
    TERRAIN_TUNDRA,
    TERRAIN_JUNGLE,
    TERRAIN_COUNT
} TerrainType;

// Unit types
typedef enum {
    UNIT_SETTLER,
    UNIT_WARRIOR,
    UNIT_ARCHER,
    UNIT_SWORDSMAN,
    UNIT_KNIGHT,
    UNIT_MUSKETEER,
    UNIT_CANNON,
    UNIT_TANK,
    UNIT_COUNT
} UnitType;

// Building types
typedef enum {
    BUILDING_MONUMENT,
    BUILDING_GRANARY,
    BUILDING_LIBRARY,
    BUILDING_TEMPLE,
    BUILDING_BARRACKS,
    BUILDING_WALLS,
    BUILDING_UNIVERSITY,
    BUILDING_FACTORY,
    BUILDING_COUNT
} BuildingType;

// Technology types
typedef enum {
    TECH_AGRICULTURE,
    TECH_POTTERY,
    TECH_WRITING,
    TECH_MATHEMATICS,
    TECH_CONSTRUCTION,
    TECH_PHILOSOPHY,
    TECH_ENGINEERING,
    TECH_EDUCATION,
    TECH_GUNPOWDER,
    TECH_INDUSTRIALIZATION,
    TECH_COUNT
} TechType;

// Civilization types
typedef enum {
    CIV_EGYPT,
    CIV_GREECE,
    CIV_ROME,
    CIV_CHINA,
    CIV_PERSIA,
    CIV_INCA,
    CIV_ENGLAND,
    CIV_FRANCE,
    CIV_COUNT
} CivType;

// City structure
typedef struct {
    char name[50];
    int population;
    int production;
    int food;
    int owner_id;
    BuildingType buildings[20];
    int building_count;
    UnitType production_queue[10];
    int queue_count;
    int production_progress;
} City;

// Map tile structure
typedef struct {
    TerrainType terrain;
    char resource[20];
    bool improved;
    int city_id; // -1 if no city
    int unit_id; // -1 if no unit
    int owner_id; // -1 if unclaimed
} Tile;

// Unit structure
typedef struct {
    UnitType type;
    int health;
    int movement;
    int strength;
    int experience;
    int owner_id;
    int x, y; // Position on map
} Unit;

// Player structure
typedef struct {
    char name[50];
    CivType civ_type;
    City cities[MAX_CITIES];
    int city_count;
    Unit units[MAX_UNITS];
    int unit_count;
    bool techs[TECH_COUNT];
    TechType researching;
    int gold;
    int happiness;
    bool is_ai;
    int relations[MAX_PLAYERS]; // Relations with other players
} Player;

// Game state structure
typedef struct {
    int year;
    Tile map[MAP_HEIGHT][MAP_WIDTH];
    Player players[MAX_PLAYERS];
    int player_count;
    int current_player;
    int winner_id;
} Game;

// Terrain names
const char* terrain_names[] = {
    "Ocean", "Plains", "Desert", "Mountains", 
    "Forest", "Hills", "Tundra", "Jungle"
};

// Unit names
const char* unit_names[] = {
    "Settler", "Warrior", "Archer", "Swordsman",
    "Knight", "Musketeer", "Cannon", "Tank"
};

// Building names
const char* building_names[] = {
    "Monument", "Granary", "Library", "Temple",
    "Barracks", "Walls", "University", "Factory"
};

// Tech names
const char* tech_names[] = {
    "Agriculture", "Pottery", "Writing", "Mathematics",
    "Construction", "Philosophy", "Engineering", "Education",
    "Gunpowder", "Industrialization"
};

// Civ names
const char* civ_names[] = {
    "Egypt", "Greece", "Rome", "China",
    "Persia", "Inca", "England", "France"
};

// Function prototypes
void init_game(Game* game, int player_count);
void generate_map(Game* game);
void create_players(Game* game, int player_count);
void run_game(Game* game);
void player_turn(Game* game);
void ai_turn(Game* game);
void end_year(Game* game);
bool check_game_over(Game* game);
void display_winner(Game* game);
void display_map(Game* game);
void display_player_status(Game* game, int player_id);
void manage_cities(Game* game);
void move_unit(Game* game);
void found_city(Game* game);
void research_tech(Game* game);
void produce_unit(City* city, UnitType type);
void build_building(City* city, BuildingType type);
int calculate_score(Game* game, int player_id);

int main() {
    srand(time(NULL));
    
    int player_count;
    printf("Enter number of players (2-8): ");
    scanf("%d", &player_count);
    
    if (player_count < 2 || player_count > 8) {
        printf("Invalid number of players. Using default 4 players.\n");
        player_count = 4;
    }
    
    Game game;
    init_game(&game, player_count);
    run_game(&game);
    
    return 0;
}

// Initialize game state
void init_game(Game* game, int player_count) {
    game->year = START_YEAR;
    game->player_count = player_count;
    game->current_player = 0;
    game->winner_id = -1;
    
    generate_map(game);
    create_players(game, player_count);
}

// Generate game map
void generate_map(Game* game) {
    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            // Random terrain
            TerrainType terrain = rand() % TERRAIN_COUNT;
            
            // Add resources (10% chance)
            const char* resources[] = {"", "Wheat", "Fish", "Gold", "Iron", "Horses"};
            char resource[20] = "";
            if (rand() % 10 == 0) {
                strcpy(resource, resources[rand() % (sizeof(resources)/sizeof(resources[0]))]);
            }
            
            game->map[y][x] = (Tile){
                .terrain = terrain,
                .resource = "",
                .improved = false,
                .city_id = -1,
                .unit_id = -1,
                .owner_id = -1
            };
            
            if (strlen(resource) > 0) {
                strcpy(game->map[y][x].resource, resource);
            }
        }
    }
}

// Create players
void create_players(Game* game, int player_count) {
    for (int i = 0; i < player_count; i++) {
        Player player;
        strcpy(player.name, civ_names[i]);
        player.civ_type = i;
        player.city_count = 0;
        player.unit_count = 0;
        player.gold = 100;
        player.happiness = 100;
        player.is_ai = i > 0; // First player is human
        
        // Initialize techs
        for (int j = 0; j < TECH_COUNT; j++) {
            player.techs[j] = false;
        }
        player.techs[TECH_AGRICULTURE] = true; // Starting tech
        player.researching = TECH_POTTERY;
        
        // Initialize relations
        for (int j = 0; j < MAX_PLAYERS; j++) {
            player.relations[j] = 0;
        }
        
        // Find a valid starting position
        int start_x, start_y;
        do {
            start_x = rand() % MAP_WIDTH;
            start_y = rand() % MAP_HEIGHT;
        } while (game->map[start_y][start_x].terrain == TERRAIN_OCEAN || 
                 game->map[start_y][start_x].terrain == TERRAIN_MOUNTAINS);
        
        // Create capital city
        City capital;
        snprintf(capital.name, sizeof(capital.name), "%s Capital", player.name);
        capital.population = 1;
        capital.production = 0;
        capital.food = 0;
        capital.owner_id = i;
        capital.building_count = 0;
        capital.queue_count = 0;
        capital.production_progress = 0;
        
        player.cities[player.city_count++] = capital;
        game->map[start_y][start_x].city_id = player.city_count - 1;
        game->map[start_y][start_x].owner_id = i;
        
        // Create starting units
        Unit settler = {UNIT_SETTLER, 100, 2, 0, 0, i, start_x, start_y};
        Unit warrior = {UNIT_WARRIOR, 100, 2, 10, 0, i, start_x, start_y};
        
        player.units[player.unit_count++] = settler;
        player.units[player.unit_count++] = warrior;
        game->map[start_y][start_x].unit_id = player.unit_count - 1;
        
        // Place warrior nearby
        int warrior_x = (start_x + 1) % MAP_WIDTH;
        int warrior_y = start_y;
        game->map[warrior_y][warrior_x].unit_id = player.unit_count - 1;
        warrior.x = warrior_x;
        warrior.y = warrior_y;
        player.units[player.unit_count - 1] = warrior;
        
        game->players[i] = player;
    }
}

// Main game loop
void run_game(Game* game) {
    while (!check_game_over(game)) {
        Player* current = &game->players[game->current_player];
        
        printf("\n======= %s's Turn (%d BC) =======\n", current->name, game->year);
        
        if (current->is_ai) {
            ai_turn(game);
        } else {
            player_turn(game);
        }
        
        // Move to next player
        game->current_player = (game->current_player + 1) % game->player_count;
        
        // End of year processing
        if (game->current_player == 0) {
            end_year(game);
        }
    }
    
    display_winner(game);
}

// AI player turn
void ai_turn(Game* game) {
    Player* player = &game->players[game->current_player];
    printf("\nü§ñ %s's turn (AI)\n", player->name);
    
    // Simple AI behavior
    for (int i = 0; i < player->city_count; i++) {
        City* city = &player->cities[i];
        
        // Randomly decide to produce a unit or building
        if (city->queue_count == 0) {
            if (rand() % 2 == 0) {
                // Produce a unit
                UnitType unit = rand() % UNIT_COUNT;
                city->production_queue[city->queue_count++] = unit;
                city->production_progress = 100;
                printf("üè≠ Started producing %s\n", unit_names[unit]);
            } else {
                // Build a building
                BuildingType building = rand() % BUILDING_COUNT;
                city->production_queue[city->queue_count++] = building;
                city->production_progress = 50;
                printf("üèóÔ∏è Started building %s\n", building_names[building]);
            }
        }
    }
    
    // Move units randomly
    for (int i = 0; i < player->unit_count; i++) {
        Unit* unit = &player->units[i];
        int dx = (rand() % 3) - 1; // -1, 0, or 1
        int dy = (rand() % 3) - 1;
        
        int new_x = (unit->x + dx + MAP_WIDTH) % MAP_WIDTH;
        int new_y = (unit->y + dy + MAP_HEIGHT) % MAP_HEIGHT;
        
        // Check if move is valid
        if (game->map[new_y][new_x].terrain != TERRAIN_OCEAN && 
            game->map[new_y][new_x].terrain != TERRAIN_MOUNTAINS) {
            
            // Clear old position
            game->map[unit->y][unit->x].unit_id = -1;
            
            // Set new position
            unit->x = new_x;
            unit->y = new_y;
            game->map[new_y][new_x].unit_id = i;
            
            printf("üö∂ Moved unit to (%d, %d)\n", new_x, new_y);
        }
    }
    
    printf("ü§ñ End of turn\n");
}

// Player turn
void player_turn(Game* game) {
    int choice;
    
    while (1) {
        printf("\nüéÆ Player Menu:\n");
        printf("1. View Map\n");
        printf("2. Manage Cities\n");
        printf("3. Move Units\n");
        printf("4. Found City\n");
        printf("5. Research Technology\n");
        printf("6. View Status\n");
        printf("7. End Turn\n");
        printf("Choose an action: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                display_map(game);
                break;
            case 2:
                manage_cities(game);
                break;
            case 3:
                move_unit(game);
                break;
            case 4:
                found_city(game);
                break;
            case 5:
                research_tech(game);
                break;
            case 6:
                display_player_status(game, game->current_player);
                break;
            case 7:
                printf("Ending turn...\n");
                return;
            default:
                printf("Invalid choice\n");
        }
    }
}

// End of year processing
void end_year(Game* game) {
    game->year += 10;
    
    printf("\nüìÖ Year %d BC\n", game->year);
    
    // Update all players
    for (int p = 0; p < game->player_count; p++) {
        Player* player = &game->players[p];
        
        // Update cities
        for (int c = 0; c < player->city_count; c++) {
            City* city = &player->cities[c];
            
            // City growth
            city->population += rand() % 2; // 0 or 1
            city->food += city->population * 2;
            
            // Process production queue
            if (city->queue_count > 0) {
                if (city->production_progress <= 0) {
                    // Production complete
                    UnitType unit = city->production_queue[0];
                    
                    // Create new unit
                    Unit new_unit;
                    new_unit.type = unit;
                    new_unit.health = 100;
                    new_unit.owner_id = p;
                    new_unit.x = -1;
                    new_unit.y = -1;
                    
                    // Find position near city
                    for (int y = city->population; y >= 0; y--) {
                        for (int x = city->population; x >= 0; x--) {
                            int check_x = (x + city->population) % MAP_WIDTH;
                            int check_y = (y + city->population) % MAP_HEIGHT;
                            
                            if (game->map[check_y][check_x].unit_id == -1) {
                                new_unit.x = check_x;
                                new_unit.y = check_y;
                                game->map[check_y][check_x].unit_id = player->unit_count;
                                break;
                            }
                        }
                        if (new_unit.x != -1) break;
                    }
                    
                    if (new_unit.x != -1) {
                        player->units[player->unit_count++] = new_unit;
                        printf("üè≠ %s produced a %s\n", city->name, unit_names[unit]);
                    }
                    
                    // Remove from queue
                    for (int i = 0; i < city->queue_count - 1; i++) {
                        city->production_queue[i] = city->production_queue[i + 1];
                    }
                    city->queue_count--;
                } else {
                    city->production_progress -= 10; // Work on production
                }
            }
        }
        
        // Research technology
        if (rand() % 100 < 30) { // 30% chance to complete research
            player->techs[player->researching] = true;
            printf("üî¨ %s researched %s\n", player->name, tech_names[player->researching]);
            player->researching = (player->researching + 1) % TECH_COUNT;
        }
    }
}

// Check if game is over
bool check_game_over(Game* game) {
    // Time victory
    if (game->year >= END_YEAR) {
        int highest_score = 0;
        for (int i = 0; i < game->player_count; i++) {
            int score = calculate_score(game, i);
            if (score > highest_score) {
                highest_score = score;
                game->winner_id = i;
            }
        }
        return true;
    }
    
    // Conquest victory
    for (int i = 0; i < game->player_count; i++) {
        if (game->players[i].city_count == 0) continue; // Player eliminated
        
        bool all_conquered = true;
        for (int j = 0; j < game->player_count; j++) {
            if (i != j && game->players[j].city_count > 0) {
                all_conquered = false;
                break;
            }
        }
        
        if (all_conquered) {
            game->winner_id = i;
            return true;
        }
    }
    
    return false;
}

// Display winner
void display_winner(Game* game) {
    Player* winner = &game->players[game->winner_id];
    printf("\nüèÜüèÜüèÜ Game Over! üèÜüèÜüèÜ\n");
    printf("üéâ Winner: %s\n", winner->name);
    printf("Age: %d BC | Score: %d\n", game->year, calculate_score(game, game->winner_id));
    
    // Display scores
    printf("\nFinal Scores:\n");
    for (int i = 0; i < game->player_count; i++) {
        printf("%s: %d\n", game->players[i].name, calculate_score(game, i));
    }
}

// Display map
void display_map(Game* game) {
    printf("\nüó∫Ô∏è World Map:\n");
    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            Tile tile = game->map[y][x];
            char symbol;
            
            switch (tile.terrain) {
                case TERRAIN_OCEAN: symbol = '~'; break;
                case TERRAIN_PLAINS: symbol = '.'; break;
                case TERRAIN_DESERT: symbol = 'd'; break;
                case TERRAIN_MOUNTAINS: symbol = '^'; break;
                case TERRAIN_FOREST: symbol = '*'; break;
                case TERRAIN_HILLS: symbol = 'h'; break;
                case TERRAIN_TUNDRA: symbol = 't'; break;
                case TERRAIN_JUNGLE: symbol = 'j'; break;
                default: symbol = '?';
            }
            
            if (tile.unit_id != -1) {
                Unit unit = game->players[game->map[y][x].owner_id].units[tile.unit_id];
                switch (unit.type) {
                    case UNIT_SETTLER: symbol = 'S'; break;
                    case UNIT_WARRIOR: symbol = 'W'; break;
                    case UNIT_ARCHER: symbol = 'A'; break;
                    case UNIT_SWORDSMAN: symbol = 's'; break;
                    case UNIT_KNIGHT: symbol = 'K'; break;
                    case UNIT_MUSKETEER: symbol = 'M'; break;
                    case UNIT_CANNON: symbol = 'C'; break;
                    case UNIT_TANK: symbol = 'T'; break;
                }
            }
            
            if (tile.city_id != -1) {
                symbol = 'C';
            }
            
            printf("%c ", symbol);
        }
        printf("\n");
    }
}

// Display player status
void display_player_status(Game* game, int player_id) {
    Player* player = &game->players[player_id];
    printf("\nüìä %s's Status\n", player->name);
    printf("Gold: %d\n", player->gold);
    printf("Happiness: %d\n", player->happiness);
    printf("Researching: %s\n", tech_names[player->researching]);
    
    printf("\nüèôÔ∏è Cities (%d):\n", player->city_count);
    for (int i = 0; i < player->city_count; i++) {
        printf("- %s (Pop: %d)\n", player->cities[i].name, player->cities[i].population);
    }
    
    printf("\n‚öîÔ∏è Units (%d):\n", player->unit_count);
    for (int i = 0; i < player->unit_count; i++) {
        printf("- %s at (%d, %d)\n", 
               unit_names[player->units[i].type], 
               player->units[i].x, player->units[i].y);
    }
    
    printf("\nüî¨ Technologies:\n");
    for (int i = 0; i < TECH_COUNT; i++) {
        if (player->techs[i]) {
            printf("- %s\n", tech_names[i]);
        }
    }
}

// Manage cities
void manage_cities(Game* game) {
    Player* player = &game->players[game->current_player];
    
    if (player->city_count == 0) {
        printf("You have no cities!\n");
        return;
    }
    
    printf("\nüèôÔ∏è Your Cities:\n");
    for (int i = 0; i < player->city_count; i++) {
        printf("%d. %s (Pop: %d)\n", i+1, player->cities[i].name, player->cities[i].population);
    }
    
    int city_choice;
    printf("Select a city: ");
    scanf("%d", &city_choice);
    city_choice--; // Convert to 0-based index
    
    if (city_choice < 0 || city_choice >= player->city_count) {
        printf("Invalid city selection.\n");
        return;
    }
    
    City* city = &player->cities[city_choice];
    
    int action;
    do {
        printf("\nManaging %s\n", city->name);
        printf("1. Produce Unit\n");
        printf("2. Build Building\n");
        printf("3. View Production Queue\n");
        printf("4. Back\n");
        printf("Choose an action: ");
        scanf("%d", &action);
        
        switch (action) {
            case 1: {
                printf("\nAvailable Units:\n");
                for (int i = 0; i < UNIT_COUNT; i++) {
                    printf("%d. %s\n", i+1, unit_names[i]);
                }
                
                int unit_choice;
                printf("Select a unit to produce: ");
                scanf("%d", &unit_choice);
                unit_choice--; // Convert to 0-based index
                
                if (unit_choice >= 0 && unit_choice < UNIT_COUNT) {
                    city->production_queue[city->queue_count++] = unit_choice;
                    city->production_progress = 100;
                    printf("Started producing %s\n", unit_names[unit_choice]);
                } else {
                    printf("Invalid unit selection.\n");
                }
                break;
            }
            case 2: {
                printf("\nAvailable Buildings:\n");
                for (int i = 0; i < BUILDING_COUNT; i++) {
                    printf("%d. %s\n", i+1, building_names[i]);
                }
                
                int building_choice;
                printf("Select a building to construct: ");
                scanf("%d", &building_choice);
                building_choice--; // Convert to 0-based index
                
                if (building_choice >= 0 && building_choice < BUILDING_COUNT) {
                    city->production_queue[city->queue_count++] = building_choice;
                    city->production_progress = 50;
                    printf("Started building %s\n", building_names[building_choice]);
                } else {
                    printf("Invalid building selection.\n");
                }
                break;
            }
            case 3: {
                printf("\nProduction Queue:\n");
                for (int i = 0; i < city->queue_count; i++) {
                    printf("%d. %s (%d%% complete)\n", i+1, 
                           unit_names[city->production_queue[i]], 
                           (100 - city->production_progress));
                }
                break;
            }
            case 4:
                return;
            default:
                printf("Invalid option\n");
        }
    } while (action != 4);
}

// Move unit
void move_unit(Game* game) {
    Player* player = &game->players[game->current_player];
    
    if (player->unit_count == 0) {
        printf("You have no units!\n");
        return;
    }
    
    printf("\n‚öîÔ∏è Your Units:\n");
    for (int i = 0; i < player->unit_count; i++) {
        printf("%d. %s at (%d, %d)\n", 
               i+1, unit_names[player->units[i].type],
               player->units[i].x, player->units[i].y);
    }
    
    int unit_choice;
    printf("Select a unit to move: ");
    scanf("%d", &unit_choice);
    unit_choice--; // Convert to 0-based index
    
    if (unit_choice < 0 || unit_choice >= player->unit_count) {
        printf("Invalid unit selection.\n");
        return;
    }
    
    Unit* unit = &player->units[unit_choice];
    
    int dx, dy;
    printf("Enter movement direction (x y): ");
    scanf("%d %d", &dx, &dy);
    
    int new_x = (unit->x + dx + MAP_WIDTH) % MAP_WIDTH;
    int new_y = (unit->y + dy + MAP_HEIGHT) % MAP_HEIGHT;
    
    // Check if move is valid
    if (game->map[new_y][new_x].terrain == TERRAIN_OCEAN || 
        game->map[new_y][new_x].terrain == TERRAIN_MOUNTAINS) {
        printf("Cannot move to that terrain.\n");
        return;
    }
    
    // Clear old position
    game->map[unit->y][unit->x].unit_id = -1;
    
    // Set new position
    unit->x = new_x;
    unit->y = new_y;
    game->map[new_y][new_x].unit_id = unit_choice;
    
    printf("Moved unit to (%d, %d)\n", new_x, new_y);
}

// Found a new city
void found_city(Game* game) {
    Player* player = &game->players[game->current_player];
    
    // Find a settler
    int settler_id = -1;
    for (int i = 0; i < player->unit_count; i++) {
        if (player->units[i].type == UNIT_SETTLER) {
            settler_id = i;
            break;
        }
    }
    
    if (settler_id == -1) {
        printf("You have no settler units!\n");
        return;
    }
    
    Unit* settler = &player->units[settler_id];
    
    // Check if position is valid
    if (game->map[settler->y][settler->x].city_id != -1) {
        printf("There is already a city here!\n");
        return;
    }
    
    char city_name[50];
    printf("Enter name for new city: ");
    scanf("%s", city_name);
    
    // Create new city
    City new_city;
    snprintf(new_city.name, sizeof(new_city.name), "%s", city_name);
    new_city.population = 1;
    new_city.production = 0;
    new_city.food = 0;
    new_city.owner_id = game->current_player;
    new_city.building_count = 0;
    new_city.queue_count = 0;
    new_city.production_progress = 0;
    
    player->cities[player->city_count] = new_city;
    game->map[settler->y][settler->x].city_id = player->city_count;
    game->map[settler->y][settler->x].owner_id = game->current_player;
    player->city_count++;
    
    // Remove settler unit
    game->map[settler->y][settler->x].unit_id = -1;
    for (int i = settler_id; i < player->unit_count - 1; i++) {
        player->units[i] = player->units[i + 1];
    }
    player->unit_count--;
    
    printf("üèôÔ∏è Founded new city: %s\n", city_name);
}

// Research technology
void research_tech(Game* game) {
    Player* player = &game->players[game->current_player];
    
    printf("\nüî¨ Available Technologies:\n");
    for (int i = 0; i < TECH_COUNT; i++) {
        if (!player->techs[i]) {
            printf("%d. %s\n", i+1, tech_names[i]);
        }
    }
    
    int tech_choice;
    printf("Select a technology to research: ");
    scanf("%d", &tech_choice);
    tech_choice--; // Convert to 0-based index
    
    if (tech_choice >= 0 && tech_choice < TECH_COUNT && !player->techs[tech_choice]) {
        player->researching = tech_choice;
        printf("Started researching %s\n", tech_names[tech_choice]);
    } else {
        printf("Invalid technology selection.\n");
    }
}

// Calculate player score
int calculate_score(Game* game, int player_id) {
    Player* player = &game->players[player_id];
    int score = 0;
    
    // City points
    score += player->city_count * 100;
    
    // Population points
    for (int i = 0; i < player->city_count; i++) {
        score += player->cities[i].population * 50;
    }
    
    // Tech points
    for (int i = 0; i < TECH_COUNT; i++) {
        if (player->techs[i]) {
            score += 50;
        }
    }
    
    // Territory points
    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            if (game->map[y][x].owner_id == player_id) {
                score += 5;
            }
        }
    }
    
    return score;
}


üèõÔ∏è Civilization Game in C: Features and Instructions

üéÆ Game Features

1. Map System

  ‚ó¶ 20x15 grid world map

  ‚ó¶ 8 terrain types: Ocean, Plains, Desert, Mountains, Forest, Hills, Tundra, Jungle

  ‚ó¶ Resources: Wheat, Fish, Gold, Iron, Horses

2. Civilization Management

  ‚ó¶ City development: Population growth, production queues

  ‚ó¶ Unit movement: Settlers, Warriors, Archers, Knights, Tanks, etc.

  ‚ó¶ Technology research: Agriculture to Industrialization

3. Player Types

  ‚ó¶ Human player with interactive menu

  ‚ó¶ AI opponents with basic decision-making

  ‚ó¶ 8 civilizations: Egypt, Greece, Rome, China, Persia, Inca, England, France

4. Victory Conditions

  ‚ó¶ Time Victory: Highest score in 2050 AD

  ‚ó¶ Conquest Victory: Eliminate all opponents

5. Game Mechanics

  ‚ó¶ Turn-based system (10 years per turn)

  ‚ó¶ Production queues for units and buildings

  ‚ó¶ Technology research progression

  ‚ó¶ Territory control scoring

üïπÔ∏è How to Play

1. Compile the Game

gcc civilization.c -o civilization


2. Run the Game

./civilization


3. Game Controls

  ‚ó¶ Main Menu:

    ‚ñ™       1. View Map

    ‚ñ™       2. Manage Cities

    ‚ñ™       3. Move Units

    ‚ñ™       4. Found City

    ‚ñ™       5. Research Technology

    ‚ñ™       6. View Status

    ‚ñ™       7. End Turn

4. City Management

  ‚ó¶ Produce units: Settlers, Warriors, Archers, etc.

  ‚ó¶ Construct buildings: Monuments, Granaries, Libraries, etc.

  ‚ó¶ View production queues

5. Unit Movement

  ‚ó¶ Select a unit and enter movement direction (x y)

  ‚ó¶ Units can't move to ocean or mountain tiles

6. Strategy Tips

  ‚ó¶ Expand early with Settlers

  ‚ó¶ Balance military and economic development

  ‚ó¶ Research technologies to unlock advanced units

  ‚ó¶ Control territory to increase your score

üß© Game Structure

1. Data Structures

  ‚ó¶ Game: Overall game state

  ‚ó¶ Player: Civilization data

  ‚ó¶ City: City information

  ‚ó¶ Unit: Military units

  ‚ó¶ Tile: Map grid cells

2. Key Functions

  ‚ó¶ init_game(): Initialize game state

  ‚ó¶ generate_map(): Create random world map

  ‚ó¶ run_game(): Main game loop

  ‚ó¶ player_turn(): Human player actions

  ‚ó¶ ai_turn(): Computer player logic

  ‚ó¶ end_year(): Yearly processing

  ‚ó¶ check_game_over(): Victory conditions

3. Game Flow

  ‚ó¶ Players take turns managing their civilizations

  ‚ó¶ Each full round advances the game by 10 years

  ‚ó¶ Game ends when time runs out or one player conquers all others

üåü Game Experience

1. Historical Simulation

  ‚ó¶ Start in 4000 BC

  ‚ó¶ Advance through technological eras

  ‚ó¶ Build your civilization from ancient times to modern era

2. Strategic Depth

  ‚ó¶ Balance expansion, military, and research

  ‚ó¶ Make decisions that affect your civilization's growth

  ‚ó¶ Compete against AI opponents with different strategies

3. Replayability

  ‚ó¶ Random map generation

  ‚ó¶ Multiple victory conditions

  ‚ó¶ Different civilizations to play

üöÄ Getting Started

1. Compile the game:

gcc civilization.c -o civilization


2. Run the game:

./civilization


3. Game setup:

  ‚ó¶ Enter number of players (2-8)

  ‚ó¶ First player is human, others are AI

4. Gameplay:

  ‚ó¶ Build cities

  ‚ó¶ Train units

  ‚ó¶ Research technologies

  ‚ó¶ Expand your territory

  ‚ó¶ Achieve victory before 2050 AD

This implementation provides a complete, playable Civilization-style game with all core mechanics implemented in C. The game features a console-based interface with text menus and a grid-based map display.
üèõÔ∏è Civilization Game in Zig

Here's a complete implementation of a Civilization-style game in Zig, featuring map generation, city management, unit movement, technology research, and AI opponents:

const std = @import("std");
const rand = std.rand;
const heap = std.heap;
const io = std.io;
const fmt = std.fmt;
const mem = std.mem;
const time = std.time;

// Game constants
const MAP_WIDTH = 20;
const MAP_HEIGHT = 15;
const MAX_PLAYERS = 8;
const MAX_CITIES = 50;
const MAX_UNITS = 100;
const START_YEAR = 4000; // 4000 BC
const END_YEAR = 2050;   // Game end year

// Terrain types
const TerrainType = enum {
    Ocean,
    Plains,
    Desert,
    Mountains,
    Forest,
    Hills,
    Tundra,
    Jungle,
};

// Unit types
const UnitType = enum {
    Settler,
    Warrior,
    Archer,
    Swordsman,
    Knight,
    Musketeer,
    Cannon,
    Tank,
};

// Building types
const BuildingType = enum {
    Monument,
    Granary,
    Library,
    Temple,
    Barracks,
    Walls,
    University,
    Factory,
};

// Technology types
const TechType = enum {
    Agriculture,
    Pottery,
    Writing,
    Mathematics,
    Construction,
    Philosophy,
    Engineering,
    Education,
    Gunpowder,
    Industrialization,
};

// Civilization types
const CivType = enum {
    Egypt,
    Greece,
    Rome,
    China,
    Persia,
    Inca,
    England,
    France,
};

// City structure
const City = struct {
    name: []const u8,
    population: u32,
    production: u32,
    food: u32,
    owner_id: u8,
    buildings: std.ArrayList(BuildingType),
    production_queue: std.ArrayList(union(enum) { Unit: UnitType, Building: BuildingType }),
};

// Unit structure
const Unit = struct {
    type: UnitType,
    health: u8,
    movement: u8,
    strength: u8,
    experience: u8,
    owner_id: u8,
    x: u8,
    y: u8,
};

// Player structure
const Player = struct {
    name: []const u8,
    civ_type: CivType,
    cities: std.ArrayList(*City),
    units: std.ArrayList(*Unit),
    techs: std.ArrayList(TechType),
    researching: ?TechType,
    gold: u32,
    happiness: u8,
    is_ai: bool,
    relations: [MAX_PLAYERS]i8, // Relations with other players
};

// Map tile structure
const Tile = struct {
    terrain: TerrainType,
    resource: ?[]const u8,
    improved: bool,
    city: ?*City,
    unit: ?*Unit,
    owner_id: ?u8,
};

// Game state structure
const Game = struct {
    year: u32,
    map: [MAP_HEIGHT][MAP_WIDTH]Tile,
    players: std.ArrayList(Player),
    current_player_index: u8,
    winner_id: ?u8,
    allocator: std.mem.Allocator,

    // Initialize game
    fn init(allocator: std.mem.Allocator, player_count: u8) !Game {
        var self = Game{
            .year = START_YEAR,
            .map = undefined,
            .players = std.ArrayList(Player).init(allocator),
            .current_player_index = 0,
            .winner_id = null,
            .allocator = allocator,
        };
        
        try self.generateMap();
        try self.createPlayers(player_count);
        
        return self;
    }

    // Generate game map
    fn generateMap(self: *Game) !void {
        const resources = [_][]const u8{ "Wheat", "Fish", "Gold", "Iron", "Horses" };
        var rng = rand.DefaultPrng.init(@bitCast(u64, time.nanoTimestamp()));
        
        for (0..MAP_HEIGHT) |y| {
            for (0..MAP_WIDTH) |x| {
                const terrain = @enumFromInt(TerrainType, rng.random().intRangeAtMost(u8, 0, @typeInfo(TerrainType).Enum.fields.len - 1));
                const has_resource = rng.random().intRangeAtMost(u8, 0, 9) == 0;
                const resource = if (has_resource) resources[rng.random().intRangeAtMost(u8, 0, resources.len - 1)] else null;
                
                self.map[y][x] = Tile{
                    .terrain = terrain,
                    .resource = resource,
                    .improved = false,
                    .city = null,
                    .unit = null,
                    .owner_id = null,
                };
            }
        }
    }

    // Create players
    fn createPlayers(self: *Game, player_count: u8) !void {
        const civ_names = [_][]const u8{ "Egypt", "Greece", "Rome", "China", "Persia", "Inca", "England", "France" };
        var rng = rand.DefaultPrng.init(@bitCast(u64, time.nanoTimestamp()));
        
        for (0..player_count) |i| {
            const is_ai = i > 0; // First player is human
            const name = civ_names[i];
            
            var player = Player{
                .name = name,
                .civ_type = @enumFromInt(CivType, i),
                .cities = std.ArrayList(*City).init(self.allocator),
                .units = std.ArrayList(*Unit).init(self.allocator),
                .techs = std.ArrayList(TechType).init(self.allocator),
                .researching = TechType.Agriculture,
                .gold = 100,
                .happiness = 100,
                .is_ai = is_ai,
                .relations = undefined,
            };
            
            // Initialize relations
            for (&player.relations) |*relation| {
                relation.* = 0;
            }
            
            // Add starting tech
            try player.techs.append(TechType.Agriculture);
            
            // Find valid starting position
            var start_x: u8 = undefined;
            var start_y: u8 = undefined;
            while (true) {
                start_x = rng.random().intRangeAtMost(u8, 0, MAP_WIDTH - 1);
                start_y = rng.random().intRangeAtMost(u8, 0, MAP_HEIGHT - 1);
                const tile = self.map[start_y][start_x];
                if (tile.terrain != .Ocean and tile.terrain != .Mountains) break;
            }
            
            // Create capital city
            const city_name = try fmt.allocPrint(self.allocator, "{s} Capital", .{name});
            var capital = try self.allocator.create(City);
            capital.* = .{
                .name = city_name,
                .population = 1,
                .production = 0,
                .food = 0,
                .owner_id = @intCast(u8, i),
                .buildings = std.ArrayList(BuildingType).init(self.allocator),
                .production_queue = std.ArrayList(union(enum) { Unit: UnitType, Building: BuildingType }).init(self.allocator),
            };
            try player.cities.append(capital);
            self.map[start_y][start_x].city = capital;
            self.map[start_y][start_x].owner_id = @intCast(u8, i);
            
            // Create starting units
            var settler = try self.allocator.create(Unit);
            settler.* = .{
                .type = .Settler,
                .health = 100,
                .movement = 2,
                .strength = 0,
                .experience = 0,
                .owner_id = @intCast(u8, i),
                .x = start_x,
                .y = start_y,
            };
            try player.units.append(settler);
            self.map[start_y][start_x].unit = settler;
            
            var warrior = try self.allocator.create(Unit);
            warrior.* = .{
                .type = .Warrior,
                .health = 100,
                .movement = 2,
                .strength = 10,
                .experience = 0,
                .owner_id = @intCast(u8, i),
                .x = start_x,
                .y = start_y,
            };
            try player.units.append(warrior);
            
            // Place warrior nearby
            const warrior_x = if (start_x < MAP_WIDTH - 1) start_x + 1 else start_x - 1;
            self.map[start_y][warrior_x].unit = warrior;
            warrior.x = warrior_x;
            warrior.y = start_y;
            
            try self.players.append(player);
        }
    }

    // Run game
    fn run(self: *Game) !void {
        const stdout = io.getStdOut().writer();
        try stdout.print("üèõÔ∏è Welcome to Civilization!\n", .{});
        
        while (!self.checkGameOver()) {
            const player = &self.players.items[self.current_player_index];
            
            try stdout.print("\n======= {s}'s Turn ({d} BC) =======\n", .{ player.name, self.year });
            
            if (player.is_ai) {
                try self.aiTurn();
            } else {
                try self.playerTurn();
            }
            
            // Move to next player
            self.current_player_index = @intCast(u8, (self.current_player_index + 1) % self.players.items.len);
            
            // End of year
            if (self.current_player_index == 0) {
                try self.endYear();
            }
        }
        
        try self.displayWinner();
    }

    // AI player turn
    fn aiTurn(self: *Game) !void {
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        try stdout.print("ü§ñ {s} is taking its turn...\n", .{player.name});
        
        // Simple AI actions
        for (player.cities.items) |city| {
            // Randomly decide to produce a unit or building
            if (city.production_queue.items.len == 0) {
                const rng = rand.DefaultPrng.init(@bitCast(u64, time.nanoTimestamp()));
                if (rng.random().boolean()) {
                    // Produce a unit
                    const unit_type = @enumFromInt(UnitType, rng.random().intRangeAtMost(u8, 0, @typeInfo(UnitType).Enum.fields.len - 1));
                    try city.production_queue.append(.{ .Unit = unit_type });
                    try stdout.print("üè≠ Started producing {s}\n", .{@tagName(unit_type)});
                } else {
                    // Build a building
                    const building_type = @enumFromInt(BuildingType, rng.random().intRangeAtMost(u8, 0, @typeInfo(BuildingType).Enum.fields.len - 1));
                    try city.production_queue.append(.{ .Building = building_type });
                    try stdout.print("üèóÔ∏è Started building {s}\n", .{@tagName(building_type)});
                }
            }
        }
        
        // Move units randomly
        for (player.units.items) |unit| {
            const rng = rand.DefaultPrng.init(@bitCast(u64, time.nanoTimestamp()));
            const dx = rng.random().intRangeAtMost(i8, -1, 1);
            const dy = rng.random().intRangeAtMost(i8, -1, 1);
            
            const new_x = @intCast(u8, (@as(i16, unit.x) + dx) % MAP_WIDTH);
            const new_y = @intCast(u8, (@as(i16, unit.y) + dy) % MAP_HEIGHT);
            
            // Check if move is valid
            const tile = self.map[new_y][new_x];
            if (tile.terrain != .Ocean and tile.terrain != .Mountains) {
                // Clear old position
                self.map[unit.y][unit.x].unit = null;
                
                // Set new position
                unit.x = new_x;
                unit.y = new_y;
                self.map[new_y][new_x].unit = unit;
                
                try stdout.print("üö∂ Moved unit to ({d},{d})\n", .{ new_x, new_y });
            }
        }
    }

    // Human player turn
    fn playerTurn(self: *Game) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        while (true) {
            try stdout.print(
                \\\nüéÆ Menu:
                \\1. View Map
                \\2. Manage Cities
                \\3. Move Units
                \\4. Found City
                \\5. Research Technology
                \\6. View Status
                \\7. End Turn
                \\Choose an option: 
            , .{});
            
            var input: [10]u8 = undefined;
            const len = try stdin.read(&input);
            const choice = std.fmt.parseInt(u8, input[0..len], 10) catch {
                try stdout.print("Invalid input\n", .{});
                continue;
            };
            
            switch (choice) {
                1 => try self.displayMap(),
                2 => try self.manageCities(),
                3 => try self.moveUnit(),
                4 => try self.foundCity(),
                5 => try self.researchTech(),
                6 => try self.displayPlayerStatus(),
                7 => {
                    try stdout.print("Ending turn...\n", .{});
                    return;
                },
                else => try stdout.print("Invalid choice\n", .{}),
            }
        }
    }

    // End of year processing
    fn endYear(self: *Game) !void {
        const stdout = io.getStdOut().writer();
        
        self.year += 10;
        try stdout.print("\nüìÖ Year advanced to {d} BC\n", .{self.year});
        
        // Update all players
        for (self.players.items) |*player| {
            // Update cities
            for (player.cities.items) |city| {
                // City growth
                const rng = rand.DefaultPrng.init(@bitCast(u64, time.nanoTimestamp()));
                city.population += rng.random().intRangeAtMost(u32, 0, 1);
                city.food += city.population * 2;
                
                // Process production
                if (city.production_queue.items.len > 0) {
                    const item = city.production_queue.items[0];
                    switch (item) {
                        .Unit => |unit_type| {
                            if (city.production >= 100) {
                                // Create unit
                                var unit = try self.allocator.create(Unit);
                                unit.* = .{
                                    .type = unit_type,
                                    .health = 100,
                                    .movement = 2,
                                    .strength = switch (unit_type) {
                                        .Warrior => 10,
                                        .Archer => 8,
                                        .Swordsman => 12,
                                        .Knight => 15,
                                        .Musketeer => 18,
                                        .Cannon => 20,
                                        .Tank => 30,
                                        else => 0,
                                    },
                                    .experience = 0,
                                    .owner_id = city.owner_id,
                                    .x = 0,
                                    .y = 0,
                                };
                                
                                // Find position near city
                                for (0..MAP_HEIGHT) |y| {
                                    for (0..MAP_WIDTH) |x| {
                                        if (self.map[y][x].owner_id == city.owner_id and self.map[y][x].unit == null) {
                                            unit.x = @intCast(u8, x);
                                            unit.y = @intCast(u8, y);
                                            self.map[y][x].unit = unit;
                                            try player.units.append(unit);
                                            try stdout.print("üè≠ Produced {s} at ({d},{d})\n", .{ @tagName(unit_type), x, y });
                                            break;
                                        }
                                    }
                                }
                                
                                // Remove from queue
                                _ = city.production_queue.orderedRemove(0);
                                city.production = 0;
                            } else {
                                city.production += 10;
                            }
                        },
                        .Building => |building_type| {
                            if (city.production >= 50) {
                                try city.buildings.append(building_type);
                                try stdout.print("üèóÔ∏è Built {s}\n", .{@tagName(building_type)});
                                
                                // Remove from queue
                                _ = city.production_queue.orderedRemove(0);
                                city.production = 0;
                            } else {
                                city.production += 5;
                            }
                        },
                    }
                }
            }
            
            // Research technology
            const rng = rand.DefaultPrng.init(@bitCast(u64, time.nanoTimestamp()));
            if (rng.random().intRangeAtMost(u8, 0, 99) < 30) {
                if (player.researching) |tech| {
                    try player.techs.append(tech);
                    try stdout.print("üî¨ Researched {s}\n", .{@tagName(tech)});
                    
                    // Move to next tech
                    const next_tech = @enumFromInt(TechType, @enumToInt(tech) + 1);
                    if (@enumToInt(next_tech) < @typeInfo(TechType).Enum.fields.len) {
                        player.researching = next_tech;
                    } else {
                        player.researching = null;
                    }
                }
            }
        }
    }

    // Check if game is over
    fn checkGameOver(self: *Game) bool {
        // Time victory
        if (self.year >= END_YEAR) {
            var highest_score: u32 = 0;
            for (self.players.items, 0..) |player, i| {
                const score = self.calculateScore(@intCast(u8, i));
                if (score > highest_score) {
                    highest_score = score;
                    self.winner_id = @intCast(u8, i);
                }
            }
            return true;
        }
        
        // Conquest victory
        for (self.players.items, 0..) |player, i| {
            if (player.cities.items.len == 0) continue;
            
            var all_conquered = true;
            for (self.players.items) |other| {
                if (other.cities.items.len > 0 and &player != &other) {
                    all_conquered = false;
                    break;
                }
            }
            
            if (all_conquered) {
                self.winner_id = @intCast(u8, i);
                return true;
            }
        }
        
        return false;
    }

    // Display winner
    fn displayWinner(self: *Game) !void {
        const stdout = io.getStdOut().writer();
        
        if (self.winner_id) |winner_id| {
            const winner = &self.players.items[winner_id];
            try stdout.print(
                \\\nüèÜüèÜüèÜ Game Over! üèÜüèÜüèÜ
                \\üéâ Winner: {s}
                \\Year: {d} BC
                \\Cities: {d}
                \\Technologies: {d}
                \\
            , .{
                winner.name,
                self.year,
                winner.cities.items.len,
                winner.techs.items.len,
            });
        }
    }

    // Display map
    fn displayMap(self: *Game) !void {
        const stdout = io.getStdOut().writer();
        try stdout.print("\nüó∫Ô∏è World Map:\n", .{});
        
        for (self.map) |row| {
            for (row) |tile| {
                const symbol: u8 = switch (tile.terrain) {
                    .Ocean => '~',
                    .Plains => '.',
                    .Desert => 'd',
                    .Mountains => '^',
                    .Forest => '*',
                    .Hills => 'h',
                    .Tundra => 't',
                    .Jungle => 'j',
                };
                
                if (tile.city != null) {
                    try stdout.print("C", .{});
                } else if (tile.unit != null) {
                    try stdout.print("U", .{});
                } else {
                    try stdout.print("{c}", .{symbol});
                }
                try stdout.print(" ", .{});
            }
            try stdout.print("\n", .{});
        }
    }

    // Display player status
    fn displayPlayerStatus(self: *Game) !void {
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        try stdout.print(
            \\\nüìä Player Status:
            \\Name: {s}
            \\Civilization: {s}
            \\Gold: {d}
            \\Happiness: {d}
            \\Cities: {d}
            \\Units: {d}
            \\Technologies: {d}
            \\
        , .{
            player.name,
            @tagName(player.civ_type),
            player.gold,
            player.happiness,
            player.cities.items.len,
            player.units.items.len,
            player.techs.items.len,
        });
        
        if (player.researching) |tech| {
            try stdout.print("Researching: {s}\n", .{@tagName(tech)});
        }
    }

    // Manage cities
    fn manageCities(self: *Game) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        if (player.cities.items.len == 0) {
            try stdout.print("You have no cities!\n", .{});
            return;
        }
        
        try stdout.print("\nüèôÔ∏è Your Cities:\n", .{});
        for (player.cities.items, 0..) |city, i| {
            try stdout.print("{d}. {s} (Pop: {d})\n", .{ i + 1, city.name, city.population });
        }
        
        try stdout.print("Select a city: ", .{});
        var input: [10]u8 = undefined;
        const len = try stdin.read(&input);
        const choice = std.fmt.parseInt(u8, input[0..len], 10) catch {
            try stdout.print("Invalid input\n", .{});
            return;
        };
        
        if (choice < 1 or choice > player.cities.items.len) {
            try stdout.print("Invalid choice\n", .{});
            return;
        }
        
        const city = player.cities.items[choice - 1];
        
        while (true) {
            try stdout.print(
                \\\nüèôÔ∏è Managing {s}
                \\1. Produce Unit
                \\2. Build Building
                \\3. View Production Queue
                \\4. Back
                \\Choose an option: 
            , .{city.name});
            
            const len2 = try stdin.read(&input);
            const action = std.fmt.parseInt(u8, input[0..len2], 10) catch {
                try stdout.print("Invalid input\n", .{});
                continue;
            };
            
            switch (action) {
                1 => try self.produceUnit(city),
                2 => try self.buildBuilding(city),
                3 => try self.viewProductionQueue(city),
                4 => return,
                else => try stdout.print("Invalid choice\n", .{}),
            }
        }
    }

    // Produce unit
    fn produceUnit(self: *Game, city: *City) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        
        try stdout.print("\n‚öîÔ∏è Available Units:\n", .{});
        const unit_types = std.enums.values(UnitType);
        for (unit_types, 0..) |unit_type, i| {
            try stdout.print("{d}. {s}\n", .{ i + 1, @tagName(unit_type) });
        }
        
        try stdout.print("Select a unit: ", .{});
        var input: [10]u8 = undefined;
        const len = try stdin.read(&input);
        const choice = std.fmt.parseInt(u8, input[0..len], 10) catch {
            try stdout.print("Invalid input\n", .{});
            return;
        };
        
        if (choice < 1 or choice > unit_types.len) {
            try stdout.print("Invalid choice\n", .{});
            return;
        }
        
        try city.production_queue.append(.{ .Unit = unit_types[choice - 1] });
        try stdout.print("üè≠ Started producing {s}\n", .{@tagName(unit_types[choice - 1])});
    }

    // Build building
    fn buildBuilding(self: *Game, city: *City) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        
        try stdout.print("\nüèóÔ∏è Available Buildings:\n", .{});
        const building_types = std.enums.values(BuildingType);
        for (building_types, 0..) |building_type, i| {
            try stdout.print("{d}. {s}\n", .{ i + 1, @tagName(building_type) });
        }
        
        try stdout.print("Select a building: ", .{});
        var input: [10]u8 = undefined;
        const len = try stdin.read(&input);
        const choice = std.fmt.parseInt(u8, input[0..len], 10) catch {
            try stdout.print("Invalid input\n", .{});
            return;
        };
        
        if (choice < 1 or choice > building_types.len) {
            try stdout.print("Invalid choice\n", .{});
            return;
        }
        
        try city.production_queue.append(.{ .Building = building_types[choice - 1] });
        try stdout.print("üèóÔ∏è Started building {s}\n", .{@tagName(building_types[choice - 1])});
    }

    // View production queue
    fn viewProductionQueue(self: *Game, city: *City) !void {
        const stdout = io.getStdOut().writer();
        
        try stdout.print("\nüè≠ Production Queue:\n", .{});
        if (city.production_queue.items.len == 0) {
            try stdout.print("Empty\n", .{});
            return;
        }
        
        for (city.production_queue.items, 0..) |item, i| {
            switch (item) {
                .Unit => |unit| try stdout.print("{d}. {s} (Unit)\n", .{ i + 1, @tagName(unit) }),
                .Building => |building| try stdout.print("{d}. {s} (Building)\n", .{ i + 1, @tagName(building) }),
            }
        }
    }

    // Move unit
    fn moveUnit(self: *Game) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        if (player.units.items.len == 0) {
            try stdout.print("You have no units!\n", .{});
            return;
        }
        
        try stdout.print("\nüö∂ Your Units:\n", .{});
        for (player.units.items, 0..) |unit, i| {
            try stdout.print("{d}. {s} at ({d},{d})\n", .{ i + 1, @tagName(unit.type), unit.x, unit.y });
        }
        
        try stdout.print("Select a unit: ", .{});
        var input: [10]u8 = undefined;
        const len = try stdin.read(&input);
        const choice = std.fmt.parseInt(u8, input[0..len], 10) catch {
            try stdout.print("Invalid input\n", .{});
            return;
        };
        
        if (choice < 1 or choice > player.units.items.len) {
            try stdout.print("Invalid choice\n", .{});
            return;
        }
        
        const unit = player.units.items[choice - 1];
        
        try stdout.print("Enter direction (dx dy): ", .{});
        const len2 = try stdin.read(&input);
        var tokens = mem.tokenize(u8, input[0..len2], " ");
        const dx_str = tokens.next() orelse "";
        const dy_str = tokens.next() orelse "";
        
        const dx = std.fmt.parseInt(i8, dx_str, 10) catch {
            try stdout.print("Invalid dx\n", .{});
            return;
        };
        const dy = std.fmt.parseInt(i8, dy_str, 10) catch {
            try stdout.print("Invalid dy\n", .{});
            return;
        };
        
        const new_x = @intCast(u8, (@as(i16, unit.x) + dx) % MAP_WIDTH);
        const new_y = @intCast(u8, (@as(i16, unit.y) + dy) % MAP_HEIGHT);
        
        // Check if move is valid
        const tile = self.map[new_y][new_x];
        if (tile.terrain == .Ocean or tile.terrain == .Mountains) {
            try stdout.print("Cannot move to that terrain\n", .{});
            return;
        }
        
        // Clear old position
        self.map[unit.y][unit.x].unit = null;
        
        // Set new position
        unit.x = new_x;
        unit.y = new_y;
        self.map[new_y][new_x].unit = unit;
        
        try stdout.print("üö∂ Moved unit to ({d},{d})\n", .{ new_x, new_y });
    }

    // Found a new city
    fn foundCity(self: *Game) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        // Find a settler
        var settler: ?*Unit = null;
        for (player.units.items) |unit| {
            if (unit.type == .Settler) {
                settler = unit;
                break;
            }
        }
        
        if (settler == null) {
            try stdout.print("You have no settler units!\n", .{});
            return;
        }
        
        const tile = self.map[settler.?.y][settler.?.x];
        if (tile.city != null) {
            try stdout.print("There is already a city here!\n", .{});
            return;
        }
        
        try stdout.print("Enter name for new city: ", .{});
        var input: [50]u8 = undefined;
        const len = try stdin.read(&input);
        const name = input[0..len];
        
        // Create new city
        var city = try self.allocator.create(City);
        city.* = .{
            .name = try self.allocator.dupe(u8, name),
            .population = 1,
            .production = 0,
            .food = 0,
            .owner_id = player.cities.items[0].owner_id,
            .buildings = std.ArrayList(BuildingType).init(self.allocator),
            .production_queue = std.ArrayList(union(enum) { Unit: UnitType, Building: BuildingType }).init(self.allocator),
        };
        try player.cities.append(city);
        self.map[settler.?.y][settler.?.x].city = city;
        self.map[settler.?.y][settler.?.x].owner_id = player.cities.items[0].owner_id;
        
        // Remove settler unit
        self.map[settler.?.y][settler.?.x].unit = null;
        for (player.units.items, 0..) |unit, i| {
            if (unit == settler.?) {
                _ = player.units.orderedRemove(i);
                break;
            }
        }
        
        try stdout.print("üèôÔ∏è Founded new city: {s}\n", .{name});
    }

    // Research technology
    fn researchTech(self: *Game) !void {
        const stdin = io.getStdIn().reader();
        const stdout = io.getStdOut().writer();
        const player = &self.players.items[self.current_player_index];
        
        try stdout.print("\nüî¨ Available Technologies:\n", .{});
        const tech_types = std.enums.values(TechType);
        for (tech_types, 0..) |tech_type, i| {
            if (!mem.containsAtLeast(TechType, player.techs.items, 1, &.{tech_type})) {
                try stdout.print("{d}. {s}\n", .{ i + 1, @tagName(tech_type) });
            }
        }
        
        try stdout.print("Select a technology: ", .{});
        var input: [10]u8 = undefined;
        const len = try stdin.read(&input);
        const choice = std.fmt.parseInt(u8, input[0..len], 10) catch {
            try stdout.print("Invalid input\n", .{});
            return;
        };
        
        if (choice < 1 or choice > tech_types.len) {
            try stdout.print("Invalid choice\n", .{});
            return;
        }
        
        const tech = tech_types[choice - 1];
        player.researching = tech;
        try stdout.print("üî¨ Started researching {s}\n", .{@tagName(tech)});
    }

    // Calculate player score
    fn calculateScore(self: *Game, player_id: u8) u32 {
        const player = &self.players.items[player_id];
        var score: u32 = 0;
        
        // City points
        score += @intCast(u32, player.cities.items.len) * 100;
        
        // Population points
        for (player.cities.items) |city| {
            score += city.population * 50;
        }
        
        // Tech points
        score += @intCast(u32, player.techs.items.len) * 50;
        
        // Territory points
        for (self.map) |row| {
            for (row) |tile| {
                if (tile.owner_id == player_id) {
                    score += 5;
                }
            }
        }
        
        return score;
    }
};

pub fn main() !void {
    var arena = heap.ArenaAllocator.init(heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();
    
    const stdout = io.getStdOut().writer();
    const stdin = io.getStdIn().reader();
    
    try stdout.print("Enter number of players (2-8): ", .{});
    var input: [10]u8 = undefined;
    const len = try stdin.read(&input);
    const player_count = std.fmt.parseInt(u8, input[0..len], 10) catch {
        try stdout.print("Invalid input. Using default 4 players.\n", .{});
        return;
    };
    
    if (player_count < 2 or player_count > 8) {
        try stdout.print("Invalid number of players. Using default 4 players.\n", .{});
        return;
    }
    
    var game = try Game.init(allocator, player_count);
    try game.run();
}


üèõÔ∏è Civilization Game in Zig: Features and Instructions

üéÆ Game Features

1. Map System

  ‚ó¶ 20x15 grid world map

  ‚ó¶ 8 terrain types: Ocean, Plains, Desert, Mountains, Forest, Hills, Tundra, Jungle

  ‚ó¶ Resources: Wheat, Fish, Gold, Iron, Horses

2. Civilization Management

  ‚ó¶ City development: Population growth, production queues

  ‚ó¶ Unit movement: Settlers, Warriors, Archers, Knights, Tanks, etc.

  ‚ó¶ Technology research: Agriculture to Industrialization

3. Player Types

  ‚ó¶ Human player with interactive menu

  ‚ó¶ AI opponents with basic decision-making

  ‚ó¶ 8 civilizations: Egypt, Greece, Rome, China, Persia, Inca, England, France

4. Victory Conditions

  ‚ó¶ Time Victory: Highest score in 2050 AD

  ‚ó¶ Conquest Victory: Eliminate all opponents

5. Game Mechanics

  ‚ó¶ Turn-based system (10 years per turn)

  ‚ó¶ Production queues for units and buildings

  ‚ó¶ Technology research progression

  ‚ó¶ Territory control scoring

üïπÔ∏è How to Play

1. Compile and Run

zig build-exe civilization.zig
./civilization


2. Game Setup

  ‚ó¶ Enter number of players (2-8)

  ‚ó¶ First player is human, others are AI

3. Game Controls

  ‚ó¶ Main Menu:

    ‚ñ™       1. View Map

    ‚ñ™       2. Manage Cities

    ‚ñ™       3. Move Units

    ‚ñ™       4. Found City

    ‚ñ™       5. Research Technology

    ‚ñ™       6. View Status

    ‚ñ™       7. End Turn

4. City Management

  ‚ó¶ Produce units: Settlers, Warriors, Archers, etc.

  ‚ó¶ Construct buildings: Monuments, Granaries, Libraries, etc.

  ‚ó¶ View production queues

5. Unit Movement

  ‚ó¶ Select a unit and enter movement direction (dx dy)

  ‚ó¶ Units can't move to ocean or mountain tiles

6. Strategy Tips

  ‚ó¶ Expand early with Settlers

  ‚ó¶ Balance military and economic development

  ‚ó¶ Research technologies to unlock advanced units

  ‚ó¶ Control territory to increase your score

üß© Game Structure

1. Data Structures

  ‚ó¶ Game: Overall game state

  ‚ó¶ Player: Civilization data

  ‚ó¶ City: City information

  ‚ó¶ Unit: Military units

  ‚ó¶ Tile: Map grid cells

2. Key Functions

  ‚ó¶ init(): Initialize game state

  ‚ó¶ generateMap(): Create random world map

  ‚ó¶ run(): Main game loop

  ‚ó¶ playerTurn(): Human player actions

  ‚ó¶ aiTurn(): Computer player logic

  ‚ó¶ endYear(): Yearly processing

  ‚ó¶ checkGameOver(): Victory conditions

3. Game Flow

  ‚ó¶ Players take turns managing their civilizations

  ‚ó¶ Each full round advances the game by 10 years

  ‚ó¶ Game ends when time runs out or one player conquers all others

‚öôÔ∏è Zig Features Used

1. Memory Management

  ‚ó¶ Arena allocator for efficient memory management

  ‚ó¶ Explicit allocation and deallocation

2. Type Safety

  ‚ó¶ Strongly typed enums for game elements

  ‚ó¶ Compile-time checks for game logic

3. Error Handling

  ‚ó¶ Zig's error handling with try and catch

  ‚ó¶ Proper error propagation

4. Standard Library

  ‚ó¶ ArrayLists for dynamic collections

  ‚ó¶ Random number generation

  ‚ó¶ Input/output handling

5. Union Types

  ‚ó¶ Production queue with union of Unit and Building
