agenda
org-makefile

In Makefiles, a phony target is a special type of target that does not represent an actual file to be built. Instead, it serves as a label for a set of commands you want to execute. Using .PHONY is a crucial best practice to make your build system robust and reliable .

ğŸ¤” Why You Need Phony Targets

There are two primary reasons to declare a target as phony:

1. To Avoid File Conflicts: By default, make assumes a target is a file. If a file with the same name as your target (e.g., a file called clean) exists in the directory, make will see that the file is present and has no prerequisites. It will then decide the target is "up to date" and will not run the associated commands . Declaring the target as phony tells make to ignore the existence of any same-named file and always execute the commands .

2. To Improve Performance: Because phony targets do not correspond to files, make can skip the implicit rule search for them. This can lead to a slight performance improvement, which is beneficial for complex build systems .

ğŸ“ How to Use .PHONY

You declare a target as phony by placing a special line in your Makefile. The standard syntax adds the target as a prerequisite to the special .PHONY target .

# Declaration: tell make these targets are phony
.PHONY: clean all test install

# A target to build all programs
all: prog1 prog2

# A target to clean up build artifacts
clean:
    rm -rf *.o myapp

# A target to run tests
test:
    go test ./...


You can declare multiple phony targets on a single line, as shown above .

ğŸ› ï¸ Common Use Cases for Phony Targets

Phony targets are ideal for any action that doesn't produce an output file with the same name as the target. Here are the most common examples:

â€¢ all: This is often the first target and used as the default goal. It typically builds all the components of your project .

â€¢ clean: Used to remove all files generated by the build process (like object files or binaries) .

â€¢ test or check: Used to run the test suite for your project .

â€¢ install: Used to copy the built program and other necessary files to their system-wide directories .

â€¢ help: Displays available targets and their purposes .

Phony targets can also have prerequisites and be combined to create more complex operations . For example, a rebuild target might depend on clean and all.

.PHONY: rebuild all clean

# This will run the 'clean' target and then the 'all' target
rebuild: clean all

all: myapp

clean:
    rm -f myapp


ğŸ’¡ Key Practices and a Note on Dependencies

â€¢ Always Declare Non-File Targets: For any target that does not create a file with the target's name, declare it with .PHONY .

â€¢ Place Declarations Early: It's good practice to place your .PHONY declarations near the top of the Makefile, after variable definitions .

â€¢ Dependencies on Real Files: A phony target can depend on a real file. In this case, the phony target's commands will only run if the real file is newer than its prerequisites. For example, a deploy target might depend on the myapp binary; make deploy would only run if myapp is newer than the files it was built from .

In summary, using .PHONY is essential for defining utility targets like clean or all reliably. It ensures your Makefile commands execute correctly regardless of the files in your directory and can make your builds slightly faster .

;;elc

(file-size "test.elc")

;; åŠ è½½ç¼–è¯‘åçš„æ–‡ä»¶æµ‹è¯•
(load "test.elc")
;; è®¾ç½® Org ä»£ç å—æ˜¾ç¤ºæ ·å¼
(custom-set-faces
 '(org-block ((t (:background "#f0fff0" :extend t))))
 '(org-block-begin-line ((t (:underline "#90ee90" :background "#e0ffe0"))))
 '(org-block-end-line ((t (:overline "#90ee90" :background "#e0ffe0")))))



;; å¼€å¯è¯¦ç»†ç¼–è¯‘æ¨¡å¼
(setq byte-compile-verbose t)
(setq byte-compile-debug t)

;; é‡æ–°ç¼–è¯‘æŸ¥çœ‹è¯¦ç»†è¾“å‡º

7. ç¼–ç è®¾ç½®ï¼šåœ¨æ¸²æŸ“æ—¶æ˜¾å¼è®¾ç½®bufferç¼–ç 
4. ç©ºå€¼æ£€æŸ¥ï¼šåœ¨æ‰€æœ‰å¯èƒ½ä¸ºnilçš„å€¼å‰æ·»åŠ äº†å®‰å…¨æ£€æŸ¥






1. ç¼–ç ä¿®å¤ï¼šåœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ äº†UTF-8ç¼–ç å£°æ˜

2. APIå¯†é’¥æ£€æŸ¥ï¼šå¢å¼ºäº†æ£€æŸ¥é€»è¾‘ï¼Œå¤„ç†æ›´å¤šæ— æ•ˆå¯†é’¥æƒ…å†µ

3. é”™è¯¯å¤„ç†ï¼šæ”¹è¿›äº†APIå“åº”éªŒè¯å’Œé”™è¯¯å¤„ç†

4. ç©ºå€¼æ£€æŸ¥ï¼šåœ¨æ‰€æœ‰å¯èƒ½ä¸ºnilçš„å€¼å‰æ·»åŠ äº†å®‰å…¨æ£€æŸ¥

5. HTTPSæ”¯æŒï¼šå°†APIè¯·æ±‚ä»HTTPæ”¹ä¸ºHTTPS

6. æ•°æ®éªŒè¯ï¼šå¢å¼ºäº†æ•°æ®å¤„ç†çš„å¥å£®æ€§
;; -*- coding: utf-8; -*-

;; Fix the weather--filter-by-time-range function
(defun weather--filter-by-time-range (hourly-data days-back days-forward)
  "Filter data by time range"
  (let* ((now (float-time))
         (min-time (- now (* days-back 24 3600)))
         (max-time (+ now (* days-forward 24 3600))))
    (cl-remove-if-not 
     (lambda (hour)
       (let ((dt (plist-get hour :dt)))
         (and dt (>= dt min-time) (<= dt max-time))))
     hourly-data)))

;; Fix the weather-process-data function to handle errors properly
(defun weather-process-data (city data)
  "Process and store weather data for a city"
  (condition-case err
      (progn
        ;; æ£€æŸ¥APIå“åº”æ˜¯å¦åŒ…å«é”™è¯¯
        (when (and (listp data) (alist-get 'message data))
          (error "APIé”™è¯¯: %s" (alist-get 'message data)))
        
        (let* ((city-info (gethash city weather-city-data))
               (existing-hourly (or (plist-get city-info :hourly) '()))
               (api-list (alist-get 'list data))
               (new-hourly (if (and api-list (listp api-list))
                               (mapcar #'weather--create-plist api-list)
                             (error "æ— æ•ˆçš„APIå“åº”æ•°æ®: ç¼ºå°‘listå­—æ®µ")))
               (all-hourly (append existing-hourly new-hourly))
               (filtered-hourly (weather--filter-by-time-range all-hourly 1 5)))
          
          ;; æ’åºå’Œå»é‡
          (setq filtered-hourly (cl-sort filtered-hourly #'< 
                                        :key (lambda (x) (or (plist-get x :dt) 0))))
          (setq filtered-hourly (cl-remove-duplicates filtered-hourly 
                                                     :test (lambda (a b) 
                                                            (= (or (plist-get a :dt) 0) 
                                                               (or (plist-get b :dt) 0)))))
          
          ;; åˆ†ç»„ä¸ºæ¯æ—¥æ•°æ®
          (let ((daily-data (weather--group-by-date filtered-hourly)))
            (puthash city `(:city ,city 
                           :hourly ,filtered-hourly 
                           :daily ,daily-data
                           :last-update ,(current-time))
                     weather-city-data))))
    
    (error
     (let ((error-msg (format "%s: æ•°æ®å¤„ç†å¤±è´¥ - %s" city (error-message-string err))))
       (push error-msg weather-error-messages)
       (message "å¤„ç† %s å¤©æ°”æ•°æ®æ—¶å‡ºé”™: %s" city (error-message-string err))))))

;; Fix the weather-start-request function to properly handle errors
(defun weather-start-request (city)
  "Start a weather request for a specific city"
  (weather-check-api-key)
  (condition-case err
      (progn
        (cl-incf weather-active-requests)
        (let ((url (format "https://api.openweathermap.org/data/2.5/forecast?q=%s&appid=%s&units=metric&lang=zh_cn"
                          (url-hexify-string city)
                          openweather-api-key)))
          (url-retrieve url 'weather-api-callback (list city))))
    (error
     (message "å¯åŠ¨ %s å¤©æ°”è¯·æ±‚å¤±è´¥: %s" city (error-message-string err))
     (cl-decf weather-active-requests)
     (push (format "%s: è¯·æ±‚å¤±è´¥ - %s" city (error-message-string err)) weather-error-messages))))

;; Fix function to get all unique dates
(defun weather--get-all-dates ()
  "Get all unique dates from weather data"
  (let ((dates '()))
    (maphash (lambda (_ city-data)
               (let ((daily-data (plist-get city-data :daily)))
                 (when (hash-table-p daily-data)
                   (maphash (lambda (date _) 
                              (push date dates))
                            daily-data))))
             weather-city-data)
    (cl-sort (cl-remove-duplicates dates :test 'string=) 'string<)))

;; Format temperature with color coding
(defun weather--format-temperature (temp)
  "Format temperature with color coding"
  (when temp
    (let ((formatted (format "%.1fÂ°C" temp)))
      (cond ((> temp 30) (propertize formatted 'face '(:foreground "red" :weight bold)))
            ((< temp 10) (propertize formatted 'face '(:foreground "blue" :weight bold)))
            (t (propertize formatted 'face '(:foreground "dark green")))))))

;; Format precipitation percentage
(defun weather--format-pop (pop-percent highlight)
  "Format precipitation percentage with highlighting"
  (when pop-percent
    (let ((formatted (format "%d%%" pop-percent)))
      (if (and highlight (>= pop-percent rain-threshold))
          (propertize formatted 'face '(:background "light coral" :weight bold))
        formatted))))

;; Enhanced API key check
(defun weather-check-api-key ()
  "Check if API key is properly set"
  (when (or (null openweather-api-key)
            (string= openweather-api-key "YOUR_API_KEY")
            (string= openweather-api-key "YOUR_OPENWEATHER_API_KEY"))
    (error "è¯·å…ˆè®¾ç½®OpenWeatherMap APIå¯†é’¥ï¼šM-x set-variable openweather-api-key")))

;; Define OpenWeatherMap API key variable
(defvar openweather-api-key nil
  "OpenWeatherMap API key")

;; Try to get API key from environment variable
(when (and (not openweather-api-key) (getenv "WEATHER"))
  (setq openweather-api-key (getenv "WEATHER")))

;; Define list of cities to monitor weather for
(defvar weather-cities '("Beijing" "Shanghai" "Guangzhou" "Shenzhen")
  "List of cities to display weather for")

;; Other variable definitions remain the same...
(defvar weather-refresh-interval 3600
  "Weather refresh interval in seconds")

(defvar rain-threshold 30
  "Rain highlight threshold (rain probability percentage)")

(defvar weather-buffer-name "åŸå¸‚å¤©æ°”"
  "Weather report buffer name")

(defvar weather-active-requests 0
  "Number of currently active requests")

(defvar weather-city-data (make-hash-table :test 'equal)
  "Storage for city weather data")

(defvar weather-error-messages nil
  "Storage for error messages")

;;; ======================
;;; Enhanced utility functions
;;; ======================

(defun weather--format-time (timestamp &optional format)
  "Format timestamp to readable string"
  (when timestamp
    (format-time-string (or format "%Y-%m-%d %H:%M") (seconds-to-time timestamp))))

(defun weather--create-plist (item)
  "Create property list from API data item"
  (when item
    (let ((dt (alist-get 'dt item))
          (main (alist-get 'main item))
          (weather-vec (alist-get 'weather item))
          (pop (or (alist-get 'pop item) 0))
          (rain (or (alist-get 'rain item) 0))
          (wind (alist-get 'wind item)))
      
      (let ((weather (cond
                      ((vectorp weather-vec) (aref weather-vec 0))
                      ((consp weather-vec) (car weather-vec))
                      (t nil))))
        `(:dt ,dt
          :temp ,(when main (alist-get 'temp main))
          :feels_like ,(when main (alist-get 'feels_like main))
          :humidity ,(when main (alist-get 'humidity main))
          :pressure ,(when main (alist-get 'pressure main))
          :description ,(when weather (alist-get 'description weather))
          :icon ,(when weather (alist-get 'icon weather))
          :pop ,pop
          :rain ,(if (consp rain) (alist-get '3h rain) rain)
          :wind_speed ,(when wind (alist-get 'speed wind)))))))

(defun weather--group-by-date (hourly-data)
  "Group hourly data by date"
  (let ((daily-table (make-hash-table :test 'equal)))
    (dolist (hour hourly-data)
      (when (plist-get hour :dt)
        (let ((date (weather--format-time (plist-get hour :dt) "%Y-%m-%d")))
          (when date
            (push hour (gethash date daily-table '()))))))
    daily-table))

(defun weather--calculate-daily-stats (hours)
  "Calculate daily statistics from hourly data"
  (when hours
    (let ((valid-hours (cl-remove-if-not (lambda (h) (plist-get h :temp)) hours))
          (temps (mapcar (lambda (h) (plist-get h :temp)) hours))
          (pops (mapcar (lambda (h) (or (plist-get h :pop) 0)) hours))
          (rains (mapcar (lambda (h) (or (plist-get h :rain) 0)) hours)))
      
      (when valid-hours
        `(:max-temp ,(apply #'max temps)
          :min-temp ,(apply #'min temps)
          :avg-pop ,(/ (apply #'+ pops) (length pops))
          :total-rain ,(apply #'+ rains)
          :hours ,(length valid-hours))))))

;;; ======================
;;; Enhanced API callback
;;; ======================

(defun weather-api-callback (status city)
  "Callback function for API responses"
  (let ((data-buffer (current-buffer)))
    (unwind-protect
        (cond
         ((eq (car status) :error)
          (let ((error-msg (format "%s: %s" city (cdr status))))
            (push error-msg weather-error-messages)
            (message "è·å– %s å¤©æ°”å¤±è´¥: %s" city (cdr status))))
         
         (t
          (goto-char (point-min))
          (if (re-search-forward "\r?\n\r?\n" nil t)
              (let* ((json-str (buffer-substring (point) (point-max)))
                     (data (ignore-errors (json-read-from-string json-str))))
                (if data
                    (if (alist-get 'list data)
                        (weather-process-data city data)
                      (push (format "%s: APIå“åº”æ— æ•ˆ - %s" city 
                                   (or (alist-get 'message data) "æœªçŸ¥é”™è¯¯")) 
                           weather-error-messages))
                  (push (format "%s: JSONè§£æå¤±è´¥" city) weather-error-messages)))
            (push (format "%s: æ— æ•ˆçš„APIå“åº”" city) weather-error-messages)))))
      
      (when (buffer-live-p data-buffer)
        (kill-buffer data-buffer)))
    
    (cl-decf weather-active-requests)
    (when (<= weather-active-requests 0)
      (weather-render-report))))

;;; ======================
;;; Enhanced rendering functions
;;; ======================

(defun weather-render-report ()
  "Render the complete weather report"
  (let ((buffer (get-buffer-create weather-buffer-name))
        (inhibit-read-only t))
    
    (with-current-buffer buffer
      (erase-buffer)
      (setq buffer-file-coding-system 'utf-8)
      
      (weather--render-header)
      
      (when weather-error-messages
        (weather--render-errors))
      
      (when (> (hash-table-count weather-city-data) 0)
        (weather--render-summary)
        (maphash (lambda (city _) (weather--render-city-detail city)) 
                 weather-city-data))
      
      (weather--render-footer)
      
      (setq buffer-read-only t)
      (org-mode)
      ;;mrsilver
    

  (org-table-map-tables (lambda () (org-table-align)) t)
      (goto-char (point-min)))
    
    (display-buffer buffer)))

(defun weather--render-header ()
  "Render report header"
  (insert "#+TITLE: å¤šåŸå¸‚å¤©æ°”ç›‘æ§\n")
  (insert "#+AUTHOR: å¤©æ°”ç³»ç»Ÿ\n")
  (insert (format "#+DATE: %s\n\n" (format-time-string "%Yå¹´%mæœˆ%dæ—¥ %H:%M")))
  (insert (format "**ç›‘æ§åŸå¸‚**: %s\n\n" (string-join weather-cities "ã€"))))

(defun weather--render-errors ()
  "Render error messages"
  (insert "**âŒ é”™è¯¯ä¿¡æ¯**\n")
  (dolist (err weather-error-messages)
    (insert (format "- %s\n" err)))
  (insert "\n")
  (setq weather-error-messages nil))

(defun weather--render-summary ()
  "Render daily summary table"
  (insert "**ğŸ“Š æ¯æ—¥å¤©æ°”æ‘˜è¦**\n\n")
  
  (let ((all-dates (weather--get-all-dates)))
    (dolist (date (cl-subseq all-dates 0 (min 5 (length all-dates))))
      (insert (format "*** %s (%s)\n" date (weather--get-day-name date)))
      (insert "| åŸå¸‚ | æœ€é«˜æ¸© | æœ€ä½æ¸© | å¹³å‡é™é›¨æ¦‚ç‡ | æ€»é™é›¨é‡ | å¤©æ°”çŠ¶å†µ |\n")
      (insert "|------|--------|--------|--------------|----------|----------|\n")
      
      (dolist (city weather-cities)
        (let* ((city-data (gethash city weather-city-data))
               (hours (when (and city-data (plist-get city-data :daily))
                       (gethash date (plist-get city-data :daily)))))
          (if hours
              (let ((stats (weather--calculate-daily-stats hours))
                    (icon (plist-get (car hours) :icon)))
                (insert (format "| %s | %.1fÂ°C | %.1fÂ°C | %d%% | %.1fmm | %s |\n"
                               city
                               (or (plist-get stats :max-temp) 0)
                               (or (plist-get stats :min-temp) 0)
                               (round (* (or (plist-get stats :avg-pop) 0) 100))
                               (or (plist-get stats :total-rain) 0)
                               (or icon "N/A"))))
            (insert (format "| %s | - | - | - | - | æ— æ•°æ® |\n" city)))))
      (insert "\n"))))

(defun weather--render-city-detail (city)
  "Render detailed forecast for a specific city"
  (let ((city-data (gethash city weather-city-data)))
    (when city-data
      (insert (format "**ğŸŒ¤ï¸ %s è¯¦ç»†å¤©æ°”é¢„æŠ¥**\n" city))
      (insert (format "æœ€åæ›´æ–°: %s\n\n" 
                     (weather--format-time (float-time (plist-get city-data :last-update)))))
      
      (let ((daily-data (plist-get city-data :daily))
            (rain-periods '()))
        (when (hash-table-p daily-data)
          (maphash 
           (lambda (date hours)
             (insert (format "*** %s (%s)\n" date (weather--get-day-name date)))
             (insert "| æ—¶é—´ | æ¸©åº¦ | ä½“æ„Ÿ | å¤©æ°” | é™é›¨æ¦‚ç‡ | é™é›¨é‡ | é£é€Ÿ |\n")
             (insert "|------|------|------|------|----------|--------|------|\n")
             
             (dolist (hour (cl-sort hours #'< :key (lambda (h) (or (plist-get h :dt) 0))))
               (let* ((pop-percent (round (* (or (plist-get hour :pop) 0) 100)))
                      (rain-highlight (>= pop-percent rain-threshold))
                      (time (weather--format-time (plist-get hour :dt) "%H:%M")))
                 
                 (when rain-highlight
                   (push (list city date time pop-percent) rain-periods))
                 
                 (insert (format "| %s | %s | %s | %s | %s | %.1fmm | %.1fm/s |\n"
                               (or time "N/A")
                               (or (weather--format-temperature (plist-get hour :temp)) "N/A")
                               (or (weather--format-temperature (plist-get hour :feels_like)) "N/A")
                               (or (plist-get hour :description) "N/A")
                               (or (weather--format-pop pop-percent rain-highlight) "N/A")
                               (or (plist-get hour :rain) 0)
                               (or (plist-get hour :wind_speed) 0)))))
             (insert "\n"))
           daily-data))
        
        (when rain-periods
          (weather--render-rain-alerts (nreverse rain-periods)))))))

(defun weather--render-rain-alerts (periods)
  "Render rain alerts section"
  (insert "**âš ï¸ é™é›¨è­¦æŠ¥**\n")
  (insert (format "ä»¥ä¸‹æ—¶é—´æ®µé™é›¨æ¦‚ç‡è¶…è¿‡ %d%%ï¼š\n\n" rain-threshold))
  
  (let ((current-city nil)
        (current-date nil))
    (dolist (period periods)
      (let ((city (nth 0 period))
            (date (nth 1 period))
            (time (nth 2 period))
            (pop (nth 3 period)))
        
        (unless (equal city current-city)
          (insert (format "*** %s\n" city))
          (setq current-city city
                current-date nil))
        
        (unless (equal date current-date)
          (insert (format "**** %s\n" date))
          (setq current-date date))
        
        (insert (format "- %s: %d%% é™é›¨æ¦‚ç‡\n" time pop))))))

(defun weather--render-footer ()
  "Render footer with action buttons"
  (insert "---\n")
  (insert "**æ“ä½œ**\n\n")
  (insert (propertize "[[elisp:(weather-update)][ğŸ”„ ç«‹å³æ›´æ–°]]" 
                     'face '(:box (:line-width 1 :color "blue") 
                            :background "light cyan")
                     'mouse-face 'highlight
                     'help-echo "ç‚¹å‡»æ‰‹åŠ¨åˆ·æ–°å¤©æ°”æ•°æ®"))
  (insert "  ")
  (insert (propertize "[[elisp:(weather-set-cities)][âœï¸ ä¿®æ”¹åŸå¸‚]]" 
                     'face '(:box (:line-width 1 :color "green") 
                            :background "honeydew")
                     'mouse-face 'highlight
                     'help-echo "ç‚¹å‡»ä¿®æ”¹ç›‘æ§åŸå¸‚åˆ—è¡¨"))
  (insert "  ")
  (insert (propertize "[[elisp:(weather-customize)][âš™ï¸ è®¾ç½®]]" 
                     'face '(:box (:line-width 1 :color "orange") 
                            :background "seashell")
                     'mouse-face 'highlight
                     'help-echo "ç‚¹å‡»è¿›è¡Œç³»ç»Ÿè®¾ç½®"))
  (insert "\n\n"))

;;; ======================
;;; Additional utility functions
;;; ======================

(defun weather--get-day-name (date)
  "Get day name from date string"
  (let ((time (date-to-time (concat date " 00:00:00"))))
    (format-time-string "%A" time)))

;;; ======================
;;; User interaction functions
;;; ======================

(defun weather-update (&optional interactive)
  "Manual weather update function"
  (interactive "p")
  (setq weather-error-messages nil)
  (clrhash weather-city-data)
  (setq weather-active-requests 0)
  
  (dolist (city weather-cities)
    (weather-start-request city))
  
  (when interactive
    (message "å¼€å§‹æ›´æ–°å¤©æ°”æ•°æ®...")))

(defun weather-set-cities ()
  "Function to set monitored cities"
  (interactive)
  (let ((new-cities (split-string 
                    (read-string "è¾“å…¥åŸå¸‚åˆ—è¡¨(é€—å·åˆ†éš”): " 
                                (string-join weather-cities ", "))
                    ",\\s-*")))
    (when new-cities
      (setq weather-cities new-cities)
      (weather-update t))))

(defun weather-customize ()
  "Function to customize weather settings"
  (interactive)
  (customize-group 'weather))

(defun weather-auto-update ()
  "Function to enable automatic weather updates"
  (interactive)
  (cancel-function-timers 'weather-update)
  (run-with-timer 0 weather-refresh-interval 'weather-update)
  (message "å¤©æ°”è‡ªåŠ¨æ›´æ–°å·²å¯ç”¨ (æ¯ %d ç§’)" weather-refresh-interval))

;; Fixed initialization function
(defun weather-init ()
  "Initialize weather system"
  (interactive)
  (weather-check-api-key)
  (weather-auto-update)
  (weather-update t)
  (message "å¤©æ°”ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ"))

(provide 'weather)
