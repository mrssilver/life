package main

import (
	"bufio"
	"fmt"
	"math/rand"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

// ğŸ¢ åœ°äº§ç±»å‹
type EstateType int
const (
	ESTATE_HOTEL EstateType = iota
	ESTATE_RESIDENTIAL
	ESTATE_COMMERCIAL
	ESTATE_INDUSTRIAL
	ESTATE_LUXURY
)

// ğŸ’¼ ä¸šåŠ¡ç±»å‹
type BusinessType int
const (
	BUSINESS_RESTAURANT BusinessType = iota
	BUSINESS_TECH
	BUSINESS_REAL_ESTATE
	BUSINESS_RETAIL
	BUSINESS_MANUFACTURING
)

// ğŸ’” ç¦»å©šåŸå› 
type DivorceReason int
const (
	DIVORCE_ASSETS DivorceReason = iota
	DIVORCE_HEALTH
	DIVORCE_AGE
	DIVORCE_INFIDELITY
	DIVORCE_PERSONALITY
)

// ğŸ§  AIæ€§æ ¼ç±»å‹
const (
	AI_CONSERVATIVE = "ä¿å®ˆå‹"
	AI_AGGRESSIVE   = "è¿›å–å‹"
	AI_BALANCED     = "å¹³è¡¡å‹"
	AI_FAMILY       = "å®¶åº­å‹"
)

// ğŸ¢ åœ°äº§ç»“æ„
type Estate struct {
	ID            int
	Name          string
	Type          EstateType
	BasePrice     float64
	CurrentPrice  float64
	Rent          float64
	Owner         *Player
	Tenant        *Player
	Employees     int
	Stars         int       // é…’åº—æ˜Ÿçº§
	OccupancyRate int       // å…¥ä½ç‡
	LastSold      bool      // ä¸Šå›åˆæ˜¯å¦å‡ºå”®
}

// ğŸ“ˆ è‚¡ç¥¨ç»“æ„
type Stock struct {
	ID          int
	CompanyName string
	Ticker      string
	TotalShares int
	Price       float64
	Profit      float64     // å¹´åº¦åˆ©æ¶¦
	Dividend    float64     // æ¯è‚¡åˆ†çº¢
	Owners      map[*Player]int
}

// ğŸ’ å©šå§»ç»“æ„
type Marriage struct {
	Husband     *Player
	Wife        *Player
	Date        string
	Children    []*Player
	IsActive    bool
}

// ğŸ’” ç¦»å©šç»“æ„
type Divorce struct {
	Reason      DivorceReason
	Date        string
	AssetSplit  float64 // èµ„äº§åˆ†å‰²æ¯”ä¾‹
	Custody     string  // å­å¥³æŠšå…»æƒ
	Alimony     float64 // èµ¡å…»è´¹
}

// ğŸ§‘ ç©å®¶ç»“æ„
type Player struct {
	ID            int
	Name          string
	Age           int
	Cash          float64
	Health        int
	Intelligence  int
	Charisma      int
	Luck          int
	Estates       []*Estate
	Stocks        map[*Stock]int
	Businesses    []*Business
	Spouse        *Player
	Marriage      *Marriage
	Divorces      []*Divorce
	IsAI          bool
	AIPersonality string
	Debt          float64
	IsBankrupt    bool
	NetWorth      float64
}

// ğŸ’¼ ä¸šåŠ¡ç»“æ„
type Business struct {
	ID        int
	Name      string
	Type      BusinessType
	Value     float64
	Revenue   float64
	Expenses  float64
	Employees int
	Owner     *Player
}

// ğŸ® æ¸¸æˆçŠ¶æ€
type Game struct {
	Players     []*Player
	Year        int
	Estates     []*Estate
	Stocks      []*Stock
	Businesses  []*Business
	MarketTrend float64
}

// ğŸ¯ åˆå§‹åŒ–æ¸¸æˆ
func NewGame(numPlayers int) *Game {
	rand.Seed(time.Now().UnixNano())
	
	game := &Game{
		Year:       2023,
		MarketTrend: 1.0,
	}
	
	// åˆ›å»ºç©å®¶
	for i := 0; i < numPlayers; i++ {
		player := &Player{
			ID:           i + 1,
			Name:         fmt.Sprintf("ç©å®¶%d", i+1),
			Age:          18,
			Cash:         100000,
			Health:       100,
			Intelligence: 70 + rand.Intn(30),
			Charisma:     60 + rand.Intn(30),
			Luck:         50 + rand.Intn(30),
			Stocks:       make(map[*Stock]int),
		}
		
		if i > 0 { // ç¬¬ä¸€ä¸ªç©å®¶æ˜¯äººç±»ï¼Œå…¶ä»–æ˜¯AI
			player.IsAI = true
			personalities := []string{AI_CONSERVATIVE, AI_AGGRESSIVE, AI_BALANCED, AI_FAMILY}
			player.AIPersonality = personalities[rand.Intn(len(personalities))]
		}
		
		game.Players = append(game.Players, player)
	}
	
	// åˆ›å»ºåœ°äº§
	game.generateEstates()
	
	// åˆ›å»ºè‚¡ç¥¨
	game.generateStocks()
	
	// åˆ›å»ºä¸šåŠ¡
	game.generateBusinesses()
	
	return game
}

// ğŸ¢ ç”Ÿæˆåœ°äº§
func (g *Game) generateEstates() {
	estateNames := []string{
		"æ»¨æµ·åº¦å‡é…’åº—", "åŸå¸‚å•†åŠ¡é…’åº—", "è±ªåäº”æ˜Ÿé…’åº—", "ç²¾å“è®¾è®¡é…’åº—", "æ¸©æ³‰åº¦å‡æ‘",
		"å¸‚ä¸­å¿ƒå…¬å¯“", "æµ·æ»¨åˆ«å¢…", "å•†ä¸šä¸­å¿ƒ", "å·¥ä¸šå›­", "ç§‘æŠ€å›­åŒº",
	}
	
	for i := 0; i < 200; i++ {
		estateType := EstateType(rand.Intn(5))
		basePrice := 0.0
		stars := 0
		
		switch estateType {
		case ESTATE_HOTEL:
			stars = 3 + rand.Intn(5) // 3-7æ˜Ÿ
			basePrice = 500000 * float64(stars)
		case ESTATE_RESIDENTIAL:
			basePrice = 200000 + rand.Float64()*300000
		case ESTATE_COMMERCIAL:
			basePrice = 500000 + rand.Float64()*500000
		case ESTATE_INDUSTRIAL:
			basePrice = 300000 + rand.Float64()*400000
		case ESTATE_LUXURY:
			basePrice = 1000000 + rand.Float64()*2000000
		}
		
		estate := &Estate{
			ID:           i + 1,
			Name:         fmt.Sprintf("%s %d", estateNames[i%len(estateNames)], i+1),
			Type:         estateType,
			BasePrice:    basePrice,
			CurrentPrice: basePrice,
			Rent:         basePrice * 0.05,
			Stars:        stars,
			OccupancyRate: 50 + rand.Intn(40), // 50-90%å…¥ä½ç‡
		}
		
		g.Estates = append(g.Estates, estate)
	}
}

// ğŸ“ˆ ç”Ÿæˆè‚¡ç¥¨
func (g *Game) generateStocks() {
	companies := []struct {
		Name   string
		Ticker string
		Value  float64
	}{
		{"ç§‘æŠ€å·¨å¤´", "TECH", 1000000},
		{"é‡‘èé›†å›¢", "FINA", 800000},
		{"èƒ½æºå…¬å¸", "ENER", 1200000},
		{"åŒ»ç–—å¥åº·", "HEAL", 900000},
		{"é›¶å”®å¸å›½", "RETL", 700000},
	}
	
	for i, c := range companies {
		stock := &Stock{
			ID:          i + 1,
			CompanyName: c.Name,
			Ticker:      c.Ticker,
			TotalShares: 1000,
			Price:       c.Value / 1000,
			Owners:      make(map[*Player]int),
		}
		g.Stocks = append(g.Stocks, stock)
	}
}

// ğŸ’¼ ç”Ÿæˆä¸šåŠ¡
func (g *Game) generateBusinesses() {
	businessNames := []string{
		"é«˜ç«¯é¤å…", "ç§‘æŠ€åˆ›ä¸šå…¬å¸", "æˆ¿åœ°äº§ä¸­ä»‹", "è¿é”é›¶å”®åº—", "åˆ¶é€ å·¥å‚",
	}
	
	for i := 0; i < 50; i++ {
		businessType := BusinessType(rand.Intn(5))
		value := 0.0
		
		switch businessType {
		case BUSINESS_RESTAURANT:
			value = 50000 + rand.Float64()*50000
		case BUSINESS_TECH:
			value = 200000 + rand.Float64()*300000
		case BUSINESS_REAL_ESTATE:
			value = 300000 + rand.Float64()*200000
		case BUSINESS_RETAIL:
			value = 100000 + rand.Float64()*100000
		case BUSINESS_MANUFACTURING:
			value = 400000 + rand.Float64()*300000
		}
		
		business := &Business{
			ID:        i + 1,
			Name:      fmt.Sprintf("%s %d", businessNames[i%len(businessNames)], i+1),
			Type:      businessType,
			Value:     value,
			Revenue:   value * 0.2,
			Expenses:  value * 0.1,
			Employees: 10 + rand.Intn(40),
		}
		g.Businesses = append(g.Businesses, business)
	}
}

// ğŸ’ æ±‚å©š
func (g *Game) proposeMarriage(proposer, target *Player) {
	if proposer.Spouse != nil || target.Spouse != nil {
		fmt.Println("ä¸€æ–¹å·²æœ‰é…å¶")
		return
	}
	
	if proposer.Age < 25 || target.Age < 25 {
		fmt.Println("å¹´é¾„ä¸è¶³25å²")
		return
	}
	
	// è®¡ç®—æ±‚å©šæˆåŠŸç‡
	successChance := float64(proposer.Charisma+target.Charisma) / 200.0
	if rand.Float64() < successChance {
		// åˆ›å»ºå©šå§»
		marriage := &Marriage{
			Husband:  proposer,
			Wife:     target,
			Date:     fmt.Sprintf("%då¹´", g.Year),
			IsActive: true,
		}
		
		proposer.Spouse = target
		target.Spouse = proposer
		proposer.Marriage = marriage
		target.Marriage = marriage
		
		fmt.Printf("ğŸ’ %s å’Œ %s ç»“å©šäº†!\n", proposer.Name, target.Name)
	} else {
		fmt.Printf("ğŸ’” %s æ‹’ç»äº† %s çš„æ±‚å©š\n", target.Name, proposer.Name)
	}
}

// ğŸ’” ç¦»å©š
func (g *Game) divorce(couple *Marriage, reason DivorceReason) {
	if !couple.IsActive {
		fmt.Println("å©šå§»å·²ç»“æŸ")
		return
	}
	
	// èµ„äº§åˆ†å‰²
	assetSplit := 0.5 // é»˜è®¤50%åˆ†å‰²æ¯”ä¾‹
	
	// æ ¹æ®ç¦»å©šåŸå› è°ƒæ•´åˆ†å‰²æ¯”ä¾‹
	switch reason {
	case DIVORCE_INFIDELITY:
		// ä¸å¿ æ–¹è·å¾—è¾ƒå°‘èµ„äº§
		if rand.Intn(2) == 0 {
			assetSplit = 0.3 // ä¸ˆå¤«è·å¾—30%
		} else {
			assetSplit = 0.7 // å¦»å­è·å¾—70%
		}
	case DIVORCE_ASSETS:
		assetSplit = 0.5
	case DIVORCE_HEALTH:
		assetSplit = 0.6 // å¥åº·é—®é¢˜æ–¹è·å¾—æ›´å¤š
	case DIVORCE_AGE:
		assetSplit = 0.5
	case DIVORCE_PERSONALITY:
		assetSplit = 0.5
	}
	
	// åˆ†å‰²èµ„äº§
	g.splitAssets(couple.Husband, couple.Wife, assetSplit)
	
	// å­å¥³æŠšå…»æƒ
	custody := "å…±åŒæŠšå…»"
	if len(couple.Children) > 0 {
		if rand.Intn(100) < 70 {
			custody = "æ¯äº²"
		} else {
			custody = "çˆ¶äº²"
		}
	}
	
	// èµ¡å…»è´¹
	alimony := 0.0
	if couple.Husband.NetWorth > couple.Wife.NetWorth {
		alimony = couple.Husband.NetWorth * 0.1
	} else if couple.Wife.NetWorth > couple.Husband.NetWorth {
		alimony = couple.Wife.NetWorth * 0.1
	}
	
	// åˆ›å»ºç¦»å©šè®°å½•
	divorce := Divorce{
		Reason:     reason,
		Date:       fmt.Sprintf("%då¹´", g.Year),
		AssetSplit: assetSplit,
		Custody:    custody,
		Alimony:    alimony,
	}
	
	couple.Husband.Divorces = append(couple.Husband.Divorces, divorce)
	couple.Wife.Divorces = append(couple.Wife.Divorces, divorce)
	
	// ç»“æŸå©šå§»
	couple.IsActive = false
	couple.Husband.Spouse = nil
	couple.Wife.Spouse = nil
	couple.Husband.Marriage = nil
	couple.Wife.Marriage = nil
	
	fmt.Printf("ğŸ’” %s å’Œ %s ç¦»å©šäº†! åŸå› : %s\n", 
		couple.Husband.Name, couple.Wife.Name, reasonToString(reason))
	fmt.Printf("èµ„äº§åˆ†å‰²: %.0f%% | å­å¥³æŠšå…»æƒ: %s | èµ¡å…»è´¹: $%.2f/å¹´\n", 
		assetSplit*100, custody, alimony)
}

// ğŸ’° åˆ†å‰²èµ„äº§
func (g *Game) splitAssets(husband, wife *Player, splitRatio float64) {
	// åˆ†å‰²ç°é‡‘
	totalCash := husband.Cash + wife.Cash
	husband.Cash = totalCash * splitRatio
	wife.Cash = totalCash * (1 - splitRatio)
	
	// åˆ†å‰²åœ°äº§
	g.splitEstates(husband, wife, splitRatio)
	
	// åˆ†å‰²è‚¡ç¥¨
	g.splitStocks(husband, wife, splitRatio)
	
	// åˆ†å‰²ä¸šåŠ¡
	g.splitBusinesses(husband, wife, splitRatio)
}

// ğŸ¢ åˆ†å‰²åœ°äº§
func (g *Game) splitEstates(husband, wife *Player, splitRatio float64) {
	// ä¸ˆå¤«çš„åœ°äº§
	for i := len(husband.Estates) - 1; i >= 0; i-- {
		estate := husband.Estates[i]
		if rand.Float64() > splitRatio {
			// è½¬ç§»ç»™å¦»å­
			wife.Estates = append(wife.Estates, estate)
			estate.Owner = wife
			husband.Estates = append(husband.Estates[:i], husband.Estates[i+1:]...)
		}
	}
	
	// å¦»å­çš„åœ°äº§
	for i := len(wife.Estates) - 1; i >= 0; i-- {
		estate := wife.Estates[i]
		if rand.Float64() < splitRatio {
			// è½¬ç§»ç»™ä¸ˆå¤«
			husband.Estates = append(husband.Estates, estate)
			estate.Owner = husband
			wife.Estates = append(wife.Estates[:i], wife.Estates[i+1:]...)
		}
	}
}

// ğŸ“ˆ åˆ†å‰²è‚¡ç¥¨
func (g *Game) splitStocks(husband, wife *Player, splitRatio float64) {
	// ä¸ˆå¤«çš„è‚¡ç¥¨
	for stock, shares := range husband.Stocks {
		sharesToTransfer := int(float64(shares) * (1 - splitRatio))
		if sharesToTransfer > 0 {
			wife.Stocks[stock] += sharesToTransfer
			husband.Stocks[stock] -= sharesToTransfer
			if husband.Stocks[stock] == 0 {
				delete(husband.Stocks, stock)
			}
		}
	}
	
	// å¦»å­çš„è‚¡ç¥¨
	for stock, shares := range wife.Stocks {
		sharesToTransfer := int(float64(shares) * splitRatio)
		if sharesToTransfer > 0 {
			husband.Stocks[stock] += sharesToTransfer
			wife.Stocks[stock] -= sharesToTransfer
			if wife.Stocks[stock] == 0 {
				delete(wife.Stocks, stock)
			}
		}
	}
}

// ğŸ’¼ åˆ†å‰²ä¸šåŠ¡
func (g *Game) splitBusinesses(husband, wife *Player, splitRatio float64) {
	// ä¸ˆå¤«çš„ä¸šåŠ¡
	for i := len(husband.Businesses) - 1; i >= 0; i-- {
		business := husband.Businesses[i]
		if rand.Float64() > splitRatio {
			// è½¬ç§»ç»™å¦»å­
			wife.Businesses = append(wife.Businesses, business)
			business.Owner = wife
			husband.Businesses = append(husband.Businesses[:i], husband.Businesses[i+1:]...)
		}
	}
	
	// å¦»å­çš„ä¸šåŠ¡
	for i := len(wife.Businesses) - 1; i >= 0; i-- {
		business := wife.Businesses[i]
		if rand.Float64() < splitRatio {
			// è½¬ç§»ç»™ä¸ˆå¤«
			husband.Businesses = append(husband.Businesses, business)
			business.Owner = husband
			wife.Businesses = append(wife.Businesses[:i], wife.Businesses[i+1:]...)
		}
	}
}

// ğŸ¢ è´­ä¹°åœ°äº§
func (g *Game) buyEstate(player *Player, estate *Estate) {
	if player.Cash < estate.CurrentPrice {
		fmt.Printf("èµ„é‡‘ä¸è¶³! éœ€è¦ $%.2f, åªæœ‰ $%.2f\n", estate.CurrentPrice, player.Cash)
		return
	}
	
	player.Cash -= estate.CurrentPrice
	estate.Owner = player
	player.Estates = append(player.Estates, estate)
	estate.LastSold = true
	
	fmt.Printf("âœ… %s è´­ä¹°äº† %s\n", player.Name, estate.Name)
}

// ğŸ“ˆ è´­ä¹°è‚¡ç¥¨
func (g *Game) buyStock(player *Player, stock *Stock, shares int) {
	cost := float64(shares) * stock.Price
	if player.Cash < cost {
		fmt.Printf("èµ„é‡‘ä¸è¶³! éœ€è¦ $%.2f, åªæœ‰ $%.2f\n", cost, player.Cash)
		return
	}
	
	if shares > stock.TotalShares {
		fmt.Printf("åªæœ‰ %d è‚¡å¯è´­ä¹°\n", stock.TotalShares)
		return
	}
	
	player.Cash -= cost
	player.Stocks[stock] += shares
	stock.TotalShares -= shares
	
	fmt.Printf("âœ… %s è´­ä¹°äº† %dè‚¡ %s\n", player.Name, shares, stock.CompanyName)
}

// ğŸ’¼ è´­ä¹°ä¸šåŠ¡
func (g *Game) buyBusiness(player *Player, business *Business) {
	if player.Cash < business.Value {
		fmt.Printf("èµ„é‡‘ä¸è¶³! éœ€è¦ $%.2f, åªæœ‰ $%.2f\n", business.Value, player.Cash)
		return
	}
	
	player.Cash -= business.Value
	business.Owner = player
	player.Businesses = append(player.Businesses, business)
	
	fmt.Printf("âœ… %s æ”¶è´­äº† %s\n", player.Name, business.Name)
}

// ğŸ“… ç»“æŸæœ¬å¹´
func (g *Game) endYear() {
	g.Year++
	
	// æ›´æ–°å¸‚åœºè¶‹åŠ¿
	g.updateMarketTrend()
	
	// æ‰€æœ‰ç©å®¶å¹´é¾„å¢åŠ 
	for _, player := range g.Players {
		player.Age++
		
		// æ›´æ–°å‡€èµ„äº§
		player.NetWorth = g.calculateNetWorth(player)
		
		// å¤„ç†åœ°äº§
		g.processEstates(player)
		
		// å¤„ç†è‚¡ç¥¨
		g.processStocks(player)
		
		// å¤„ç†ä¸šåŠ¡
		g.processBusinesses(player)
		
		// å¤„ç†å©šå§»
		g.processMarriages(player)
		
		// æ£€æŸ¥ç ´äº§
		if player.Cash < 0 && player.NetWorth < 0 {
			player.IsBankrupt = true
			fmt.Printf("ğŸ’¸ %s ç ´äº§äº†!\n", player.Name)
		}
	}
}

// ğŸ“ˆ æ›´æ–°å¸‚åœºè¶‹åŠ¿
func (g *Game) updateMarketTrend() {
	// éšæœºå¸‚åœºæ³¢åŠ¨ (0.8 - 1.2)
	g.MarketTrend = 0.8 + rand.Float64()*0.4
	
	// æ›´æ–°åœ°äº§ä»·æ ¼
	for _, estate := range g.Estates {
		if !estate.LastSold {
			// æœªå‡ºå”®åœ°äº§ä»·æ ¼ä¸‹é™5%
			estate.CurrentPrice *= 0.95
		}
		estate.CurrentPrice *= g.MarketTrend
		estate.Rent = estate.CurrentPrice * 0.05
		estate.LastSold = false // é‡ç½®å‡ºå”®çŠ¶æ€
	}
	
	// æ›´æ–°è‚¡ç¥¨ä»·æ ¼
	for _, stock := range g.Stocks {
		// éšæœºåˆ©æ¶¦ (-10% åˆ° +20%)
		profitRange := stock.Price * 0.3
		stock.Profit = -stock.Price*0.1 + rand.Float64()*profitRange
		
		// åˆ†çº¢ä¸ºåˆ©æ¶¦çš„50%
		stock.Dividend = stock.Profit * 0.5 / float64(stock.TotalShares)
		
		// è‚¡ä»·æ³¢åŠ¨
		change := -0.1 + rand.Float64()*0.3 // -10% åˆ° +20%
		stock.Price *= 1 + change
	}
}

// ğŸ§® è®¡ç®—å‡€èµ„äº§
func (g *Game) calculateNetWorth(player *Player) float64 {
	netWorth := player.Cash
	
	// åœ°äº§ä»·å€¼
	for _, estate := range player.Estates {
		netWorth += estate.CurrentPrice
	}
	
	// è‚¡ç¥¨ä»·å€¼
	for stock, shares := range player.Stocks {
		netWorth += float64(shares) * stock.Price
	}
	
	// ä¸šåŠ¡ä»·å€¼
	for _, business := range player.Businesses {
		netWorth += business.Value
	}
	
	// å‡å»å€ºåŠ¡
	netWorth -= player.Debt
	
	return netWorth
}

// ğŸ¢ å¤„ç†åœ°äº§
func (g *Game) processEstates(player *Player) {
	// åœ°äº§æ”¶å…¥
	for _, estate := range player.Estates {
		if estate.Tenant != nil {
			// æ”¶å–ç§Ÿé‡‘
			player.Cash += estate.Rent
			fmt.Printf("ğŸ¢ %s æ”¶å– %s ç§Ÿé‡‘: $%.2f\n", player.Name, estate.Name, estate.Rent)
		}
	}
	
	// åœ°äº§ç¨
	estateTax := float64(len(player.Estates)) * 100
	if estateTax > 0 {
		player.Cash -= estateTax
		fmt.Printf("ğŸ¢ %s ç¼´çº³åœ°äº§ç¨: $%.2f\n", player.Name, estateTax)
	}
}

// ğŸ“ˆ å¤„ç†è‚¡ç¥¨
func (g *Game) processStocks(player *Player) {
	// è‚¡ç¥¨åˆ†çº¢
	for stock, shares := range player.Stocks {
		dividend := stock.Dividend * float64(shares)
		player.Cash += dividend
		fmt.Printf("ğŸ“ˆ %s æ”¶åˆ° %s åˆ†çº¢: $%.2f\n", player.Name, stock.CompanyName, dividend)
	}
}

// ğŸ’¼ å¤„ç†ä¸šåŠ¡
func (g *Game) processBusinesses(player *Player) {
	// ä¸šåŠ¡åˆ©æ¶¦
	for _, business := range player.Businesses {
		profit := business.Revenue - business.Expenses
		player.Cash += profit
		fmt.Printf("ğŸ’¼ %s çš„ %s ç›ˆåˆ©: $%.2f\n", player.Name, business.Name, profit)
	}
}

// ğŸ’ å¤„ç†å©šå§»
func (g *Game) processMarriages(player *Player) {
	if player.Marriage != nil && player.Marriage.IsActive {
		// ç”Ÿè‚²å­å¥³
		if player.Age < 40 && rand.Intn(100) < 20 {
			child := &Player{
				ID:    len(g.Players) + 1,
				Name:  fmt.Sprintf("%sçš„å­©å­", player.Name),
				Age:   0,
			}
			player.Marriage.Children = append(player.Marriage.Children, child)
			fmt.Printf("ğŸ‘¶ %s å’Œ %s æœ‰äº†ä¸€ä¸ªå­©å­!\n", player.Name, player.Spouse.Name)
		}
		
		// å©šå§»ç¨³å®šæ€§
		stability := float64(player.Charisma+player.Spouse.Charisma) / 200.0
		if rand.Float64() > stability {
			// ç¦»å©šé£é™©
			reasons := []DivorceReason{
				DIVORCE_ASSETS,
				DIVORCE_HEALTH,
				DIVORCE_AGE,
				DIVORCE_INFIDELITY,
				DIVORCE_PERSONALITY,
			}
			g.divorce(player.Marriage, reasons[rand.Intn(len(reasons))])
		}
	}
}

// ğŸ® ä¸»æ¸¸æˆå¾ªç¯
func (g *Game) Run() {
	reader := bufio.NewReader(os.Stdin)
	
	fmt.Println("ğŸ¦ æ¬¢è¿æ¥åˆ°è´¢å¯Œäººç”Ÿæ¸¸æˆ!")
	fmt.Println("ä½ å°†ä½“éªŒç»å•†ã€æŠ•èµ„ã€å©šå§»å’Œè´¢å¯Œç®¡ç†çš„äººç”Ÿæ—…ç¨‹")
	
	// è®¾ç½®äººç±»ç©å®¶åç§°
	fmt.Print("è¯·è¾“å…¥ä½ çš„åå­—: ")
	name, _ := reader.ReadString('\n')
	g.Players[0].Name = strings.TrimSpace(name)
	
	for {
		fmt.Printf("\n======= å¹´ä»½: %d =======\n", g.Year)
		
		// ç©å®¶å›åˆ
		for _, player := range g.Players {
			if player.IsBankrupt {
				fmt.Printf("\nğŸš« %s å·²ç ´äº§ï¼Œè·³è¿‡å›åˆ\n", player.Name)
				continue
			}
			
			fmt.Printf("\n===== %s çš„å›åˆ (å¹´é¾„: %d) =====\n", player.Name, player.Age)
			fmt.Printf("ğŸ’µ ç°é‡‘: $%.2f | ğŸ’° å‡€èµ„äº§: $%.2f\n", player.Cash, player.NetWorth)
			
			if player.IsAI {
				g.aiTurn(player)
			} else {
				g.playerTurn(player)
			}
		}
		
		// ç»“æŸæœ¬å¹´
		g.endYear()
		
		// æ£€æŸ¥æ˜¯å¦ç»§ç»­æ¸¸æˆ
		fmt.Print("\nç»§ç»­ä¸‹ä¸€å¹´? (y/n): ")
		input, _ := reader.ReadString('\n')
		if strings.TrimSpace(input) != "y" {
			fmt.Println("æ¸¸æˆç»“æŸ!")
			break
		}
	}
	
	// æ˜¾ç¤ºæœ€ç»ˆæ’å
	g.displayRankings()
}

// ğŸ¤– AIç©å®¶å›åˆ
func (g *Game) aiTurn(player *Player) {
	fmt.Printf("ğŸ¤– %s çš„å›åˆ (æ€§æ ¼: %s)\n", player.Name, player.AIPersonality)
	
	// æ ¹æ®AIæ€§æ ¼å†³å®šè¡ŒåŠ¨
	switch player.AIPersonality {
	case AI_CONSERVATIVE:
		g.conservativeAIActions(player)
	case AI_AGGRESSIVE:
		g.aggressiveAIActions(player)
	case AI_BALANCED:
		g.balancedAIActions(player)
	case AI_FAMILY:
		g.familyAIActions(player)
	}
	
	fmt.Println("ğŸ¤– ç»“æŸå›åˆ")
}

// ğŸ§‘ äººç±»ç©å®¶å›åˆ
func (g *Game) playerTurn(player *Player) {
	reader := bufio.NewReader(os.Stdin)
	
	for {
		fmt.Println("\nğŸ® è¯·é€‰æ‹©è¡ŒåŠ¨:")
		fmt.Println("1. è´­ä¹°åœ°äº§")
		fmt.Println("2. è´­ä¹°è‚¡ç¥¨")
		fmt.Println("3. æ”¶è´­ä¸šåŠ¡")
		fmt.Println("4. æ±‚å©š")
		fmt.Println("5. ç®¡ç†èµ„äº§")
		fmt.Println("6. æŸ¥çœ‹çŠ¶æ€")
		fmt.Println("7. ç»“æŸå›åˆ")
		
		fmt.Print("è¯·è¾“å…¥é€‰é¡¹: ")
		input, _ := reader.ReadString('\n')
		choice, err := strconv.Atoi(strings.TrimSpace(input))
		if err != nil {
			fmt.Println("æ— æ•ˆè¾“å…¥")
			continue
		}
		
		switch choice {
		case 1:
			g.buyEstateMenu(player)
		case 2:
			g.buyStockMenu(player)
		case 3:
			g.buyBusinessMenu(player)
		case 4:
			g.proposeMenu(player)
		case 5:
			g.manageAssets(player)
		case 6:
			g.displayStatus(player)
		case 7:
			fmt.Println("ç»“æŸå›åˆ")
			return
		default:
			fmt.Println("æ— æ•ˆé€‰é¡¹")
		}
	}
}

// ğŸ¢ è´­ä¹°åœ°äº§èœå•
func (g *Game) buyEstateMenu(player *Player) {
	reader := bufio.NewReader(os.Stdin)
	
	// æ˜¾ç¤ºå¯è´­ä¹°åœ°äº§
	fmt.Println("\nğŸ¢ å¯è´­ä¹°çš„åœ°äº§:")
	for i, estate := range g.Estates {
		if estate.Owner == nil {
			fmt.Printf("%d. %s | ç±»å‹: %s | ä»·æ ¼: $%.2f | ç§Ÿé‡‘: $%.2f\n", 
				i+1, estate.Name, estateTypeToString(estate.Type), estate.CurrentPrice, estate.Rent)
		}
	}
	
	fmt.Print("é€‰æ‹©è¦è´­ä¹°çš„åœ°äº§ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(g.Estates) {
		fmt.Println("å–æ¶ˆè´­ä¹°")
		return
	}
	
	estate := g.Estates[index-1]
	if estate.Owner != nil {
		fmt.Println("è¯¥åœ°äº§å·²è¢«è´­ä¹°")
		return
	}
	
	g.buyEstate(player, estate)
}

// ğŸ“ˆ è´­ä¹°è‚¡ç¥¨èœå•
func (g *Game) buyStockMenu(player *Player) {
	reader := bufio.NewReader(os.Stdin)
	
	// æ˜¾ç¤ºå¯è´­ä¹°è‚¡ç¥¨
	fmt.Println("\nğŸ“ˆ å¯è´­ä¹°çš„è‚¡ç¥¨:")
	for i, stock := range g.Stocks {
		fmt.Printf("%d. %s (%s) | ä»·æ ¼: $%.2f | åˆ†çº¢: $%.2f\n", 
			i+1, stock.CompanyName, stock.Ticker, stock.Price, stock.Dividend)
	}
	
	fmt.Print("é€‰æ‹©è¦è´­ä¹°çš„è‚¡ç¥¨ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(g.Stocks) {
		fmt.Println("å–æ¶ˆè´­ä¹°")
		return
	}
	
	stock := g.Stocks[index-1]
	
	fmt.Print("è´­ä¹°å¤šå°‘è‚¡? ")
	input, _ = reader.ReadString('\n')
	shares, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || shares <= 0 {
		fmt.Println("æ— æ•ˆæ•°é‡")
		return
	}
	
	g.buyStock(player, stock, shares)
}

// ğŸ’¼ è´­ä¹°ä¸šåŠ¡èœå•
func (g *Game) buyBusinessMenu(player *Player) {
	reader := bufio.NewReader(os.Stdin)
	
	// æ˜¾ç¤ºå¯è´­ä¹°ä¸šåŠ¡
	fmt.Println("\nğŸ’¼ å¯æ”¶è´­çš„ä¸šåŠ¡:")
	for i, business := range g.Businesses {
		if business.Owner == nil {
			profit := business.Revenue - business.Expenses
			fmt.Printf("%d. %s | ç±»å‹: %s | ä»·å€¼: $%.2f | åˆ©æ¶¦: $%.2f\n", 
				i+1, business.Name, businessTypeToString(business.Type), business.Value, profit)
		}
	}
	
	fmt.Print("é€‰æ‹©è¦æ”¶è´­çš„ä¸šåŠ¡ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(g.Businesses) {
		fmt.Println("å–æ¶ˆæ”¶è´­")
		return
	}
	
	business := g.Businesses[index-1]
	if business.Owner != nil {
		fmt.Println("è¯¥ä¸šåŠ¡å·²è¢«æ”¶è´­")
		return
	}
	
	g.buyBusiness(player, business)
}

// ğŸ’ æ±‚å©šèœå•
func (g *Game) proposeMenu(player *Player) {
	reader := bufio.NewReader(os.Stdin)
	
	if player.Spouse != nil {
		fmt.Println("ä½ å·²æœ‰é…å¶")
		return
	}
	
	// æ˜¾ç¤ºå¯æ±‚å©šå¯¹è±¡
	fmt.Println("\nğŸ’ å¯æ±‚å©šå¯¹è±¡:")
	availablePlayers := []*Player{}
	for _, p := range g.Players {
		if p != player && p.Spouse == nil && p.Age >= 25 {
			availablePlayers = append(availablePlayers, p)
			fmt.Printf("%d. %s (å¹´é¾„: %d)\n", len(availablePlayers), p.Name, p.Age)
		}
	}
	
	if len(availablePlayers) == 0 {
		fmt.Println("æ²¡æœ‰åˆé€‚çš„æ±‚å©šå¯¹è±¡")
		return
	}
	
	fmt.Print("é€‰æ‹©æ±‚å©šå¯¹è±¡ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(availablePlayers) {
		fmt.Println("å–æ¶ˆæ±‚å©š")
		return
	}
	
	target := availablePlayers[index-1]
	g.proposeMarriage(player, target)
}

// ğŸ“Š æ˜¾ç¤ºçŠ¶æ€
func (g *Game) displayStatus(player *Player) {
	fmt.Printf("\nğŸ“Š %s çš„çŠ¶æ€\n", player.Name)
	fmt.Printf("å¹´é¾„: %d | ç°é‡‘: $%.2f | å‡€èµ„äº§: $%.2f\n", player.Age, player.Cash, player.NetWorth)
	
	if player.Spouse != nil {
		fmt.Printf("ğŸ’ é…å¶: %s (å¹´é¾„: %d)\n", player.Spouse.Name, player.Spouse.Age)
		if len(player.Marriage.Children) > 0 {
			fmt.Printf("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ å­å¥³: %d äºº\n", len(player.Marriage.Children))
		}
	}
	
	// åœ°äº§
	if len(player.Estates) > 0 {
		fmt.Println("\nğŸ¢ åœ°äº§:")
		for _, estate := range player.Estates {
			fmt.Printf("- %s | ç±»å‹: %s | ä»·å€¼: $%.2f | ç§Ÿé‡‘: $%.2f\n", 
				estate.Name, estateTypeToString(estate.Type), estate.CurrentPrice, estate.Rent)
		}
	}
	
	// è‚¡ç¥¨
	if len(player.Stocks) > 0 {
		fmt.Println("\nğŸ“ˆ è‚¡ç¥¨:")
		for stock, shares := range player.Stocks {
			value := float64(shares) * stock.Price
			fmt.Printf("- %s (%s) | æ•°é‡: %d | ä»·å€¼: $%.2f | åˆ†çº¢: $%.2f\n", 
				stock.CompanyName, stock.Ticker, shares, value, stock.Dividend)
		}
	}
	
	// ä¸šåŠ¡
	if len(player.Businesses) > 0 {
		fmt.Println("\nğŸ’¼ ä¸šåŠ¡:")
		for _, business := range player.Businesses {
			profit := business.Revenue - business.Expenses
			fmt.Printf("- %s | ç±»å‹: %s | ä»·å€¼: $%.2f | åˆ©æ¶¦: $%.2f\n", 
				business.Name, businessTypeToString(business.Type), business.Value, profit)
		}
	}
}

// ğŸ† æ˜¾ç¤ºæœ€ç»ˆæ’å
func (g *Game) displayRankings() {
	// æŒ‰å‡€èµ„äº§æ’åº
	sort.Slice(g.Players, func(i, j int) bool {
		return g.Players[i].NetWorth > g.Players[j].NetWorth
	})
	
	fmt.Println("\nğŸ† æœ€ç»ˆæ’å:")
	for i, player := range g.Players {
		status := "æ­£å¸¸"
		if player.IsBankrupt {
			status = "ç ´äº§"
		}
		fmt.Printf("%d. %s | å‡€èµ„äº§: $%.2f | çŠ¶æ€: %s\n", 
			i+1, player.Name, player.NetWorth, status)
	}
}

// ğŸ¢ åœ°äº§ç±»å‹è½¬å­—ç¬¦ä¸²
func estateTypeToString(estateType EstateType) string {
	switch estateType {
	case ESTATE_HOTEL:
		return "é…’åº—"
	case ESTATE_RESIDENTIAL:
		return "ä½å®…"
	case ESTATE_COMMERCIAL:
		return "å•†ä¸š"
	case ESTATE_INDUSTRIAL:
		return "å·¥ä¸š"
	case ESTATE_LUXURY:
		return "è±ªå"
	default:
		return "æœªçŸ¥"
	}
}

// ğŸ’¼ ä¸šåŠ¡ç±»å‹è½¬å­—ç¬¦ä¸²
func businessTypeToString(businessType BusinessType) string {
	switch businessType {
	case BUSINESS_RESTAURANT:
		return "é¤é¥®"
	case BUSINESS_TECH:
		return "ç§‘æŠ€"
	case BUSINESS_REAL_ESTATE:
		return "æˆ¿åœ°äº§"
	case BUSINESS_RETAIL:
		return "é›¶å”®"
	case BUSINESS_MANUFACTURING:
		return "åˆ¶é€ "
	default:
		return "æœªçŸ¥"
	}
}

// ğŸ’” ç¦»å©šåŸå› è½¬å­—ç¬¦ä¸²
func reasonToString(reason DivorceReason) string {
	switch reason {
	case DIVORCE_ASSETS:
		return "èµ„äº§çº çº·"
	case DIVORCE_HEALTH:
		return "å¥åº·é—®é¢˜"
	case DIVORCE_AGE:
		return "å¹´é¾„å·®è·"
	case DIVORCE_INFIDELITY:
		return "ä¸å¿ è¡Œä¸º"
	case DIVORCE_PERSONALITY:
		return "æ€§æ ¼ä¸åˆ"
	default:
		return "å…¶ä»–åŸå› "
	}
}

// ğŸ® ä¸»å‡½æ•°
func main() {
	reader := bufio.NewReader(os.Stdin)
	
	fmt.Println("ğŸ¦ è´¢å¯Œäººç”Ÿæ¸¸æˆ")
	fmt.Print("è¯·è¾“å…¥ç©å®¶æ•°é‡ (2-6): ")
	input, _ := reader.ReadString('\n')
	numPlayers, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || numPlayers < 2 || numPlayers > 6 {
		numPlayers = 4
		fmt.Println("ä½¿ç”¨é»˜è®¤ç©å®¶æ•°é‡: 4")
	}
	
	game := NewGame(numPlayers)
	game.Run()
}
