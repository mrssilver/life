
//c go
lisp treenode
æˆ‘å°†ä¸ºæ‚¨æä¾›Cè¯­è¨€å’ŒGoè¯­è¨€ä¸¤ç§ç‰ˆæœ¬çš„æ ‘å½¢æ‰“å°å®ç°ã€‚

ä¸€ã€Cè¯­è¨€ç‰ˆæœ¬

1. åŸºç¡€æ•°æ®ç»“æ„

// tree_node.h
#ifndef TREE_NODE_H
#define TREE_NODE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// æ ‘èŠ‚ç‚¹ç»“æ„
typedef struct TreeNode {
    char* value;
    struct TreeNode** children;
    int child_count;
    int capacity;
} TreeNode;

// æ ‘èŠ‚ç‚¹åˆ›å»ºå’Œé”€æ¯
TreeNode* tree_node_create(const char* value);
void tree_node_destroy(TreeNode* node);
void tree_node_add_child(TreeNode* parent, TreeNode* child);

// æ ‘å½¢æ‰“å°å‡½æ•°
void tree_print(TreeNode* root);
void tree_print_formatted(TreeNode* root, const char* format);
char* tree_to_string(TreeNode* root);
void tree_print_to_file(TreeNode* root, FILE* file);

// éå†å‡½æ•°
void tree_traverse(TreeNode* root, void (*callback)(TreeNode*, int));

#endif


2. å®ç°æ–‡ä»¶

// tree_node.c
#include "tree_node.h"
#include <stdarg.h>

// åˆ›å»ºæ–°èŠ‚ç‚¹
TreeNode* tree_node_create(const char* value) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    if (!node) return NULL;
    
    node->value = strdup(value);
    node->child_count = 0;
    node->capacity = 4;
    node->children = (TreeNode**)malloc(node->capacity * sizeof(TreeNode*));
    
    if (!node->children) {
        free(node->value);
        free(node);
        return NULL;
    }
    
    return node;
}

// é”€æ¯èŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹
void tree_node_destroy(TreeNode* node) {
    if (!node) return;
    
    for (int i = 0; i < node->child_count; i++) {
        tree_node_destroy(node->children[i]);
    }
    
    free(node->value);
    free(node->children);
    free(node);
}

// æ·»åŠ å­èŠ‚ç‚¹
void tree_node_add_child(TreeNode* parent, TreeNode* child) {
    if (!parent || !child) return;
    
    // å¦‚æœå®¹é‡ä¸è¶³ï¼Œæ‰©å®¹
    if (parent->child_count >= parent->capacity) {
        parent->capacity *= 2;
        parent->children = (TreeNode**)realloc(parent->children, 
                                               parent->capacity * sizeof(TreeNode*));
    }
    
    parent->children[parent->child_count++] = child;
}

// å†…éƒ¨é€’å½’æ‰“å°å‡½æ•°
void tree_print_recursive(TreeNode* node, const char* prefix, bool is_last) {
    if (!node) return;
    
    // æ‰“å°å½“å‰èŠ‚ç‚¹
    printf("%s", prefix);
    printf(is_last ? "â””â”€â”€ " : "â”œâ”€â”€ ");
    printf("%s\n", node->value);
    
    // æ„å»ºæ–°çš„å‰ç¼€
    char* new_prefix = (char*)malloc(strlen(prefix) + 5);
    if (!new_prefix) return;
    
    strcpy(new_prefix, prefix);
    strcat(new_prefix, is_last ? "    " : "â”‚   ");
    
    // é€’å½’æ‰“å°å­èŠ‚ç‚¹
    for (int i = 0; i < node->child_count; i++) {
        bool is_last_child = (i == node->child_count - 1);
        tree_print_recursive(node->children[i], new_prefix, is_last_child);
    }
    
    free(new_prefix);
}

// æ‰“å°æ ‘
void tree_print(TreeNode* root) {
    if (!root) {
        printf("(empty tree)\n");
        return;
    }
    tree_print_recursive(root, "", true);
}

// å°†æ ‘è½¬æ¢ä¸ºå­—ç¬¦ä¸²
typedef struct {
    char* buffer;
    size_t size;
    size_t capacity;
} StringBuffer;

static void string_buffer_init(StringBuffer* buf) {
    buf->capacity = 256;
    buf->size = 0;
    buf->buffer = (char*)malloc(buf->capacity);
    if (buf->buffer) {
        buf->buffer[0] = '\0';
    }
}

static void string_buffer_append(StringBuffer* buf, const char* str) {
    if (!buf || !str) return;
    
    size_t len = strlen(str);
    if (buf->size + len + 1 >= buf->capacity) {
        buf->capacity = (buf->size + len + 1) * 2;
        buf->buffer = (char*)realloc(buf->buffer, buf->capacity);
    }
    
    if (buf->buffer) {
        strcat(buf->buffer + buf->size, str);
        buf->size += len;
    }
}

static void tree_to_string_recursive(TreeNode* node, const char* prefix, 
                                   bool is_last, StringBuffer* buf) {
    if (!node || !buf) return;
    
    char line[1024];
    snprintf(line, sizeof(line), "%s%s%s\n", prefix,
             is_last ? "â””â”€â”€ " : "â”œâ”€â”€ ", node->value);
    string_buffer_append(buf, line);
    
    char* new_prefix = (char*)malloc(strlen(prefix) + 5);
    if (!new_prefix) return;
    
    strcpy(new_prefix, prefix);
    strcat(new_prefix, is_last ? "    " : "â”‚   ");
    
    for (int i = 0; i < node->child_count; i++) {
        bool is_last_child = (i == node->child_count - 1);
        tree_to_string_recursive(node->children[i], new_prefix, is_last_child, buf);
    }
    
    free(new_prefix);
}

char* tree_to_string(TreeNode* root) {
    if (!root) return strdup("(empty tree)\n");
    
    StringBuffer buf;
    string_buffer_init(&buf);
    
    if (!buf.buffer) return NULL;
    
    tree_to_string_recursive(root, "", true, &buf);
    return buf.buffer;
}

// å¤šç§æ ¼å¼æ‰“å°
void tree_print_compact(TreeNode* node, int depth) {
    for (int i = 0; i < depth; i++) {
        printf("  ");
    }
    printf("- %s\n", node->value);
    
    for (int i = 0; i < node->child_count; i++) {
        tree_print_compact(node->children[i], depth + 1);
    }
}

void tree_print_lisp(TreeNode* node) {
    if (node->child_count == 0) {
        printf("(%s)", node->value);
        return;
    }
    
    printf("(%s", node->value);
    for (int i = 0; i < node->child_count; i++) {
        printf(" ");
        tree_print_lisp(node->children[i]);
    }
    printf(")");
}

void tree_print_formatted(TreeNode* root, const char* format) {
    if (!root) return;
    
    if (strcmp(format, "tree") == 0) {
        tree_print(root);
    } else if (strcmp(format, "compact") == 0) {
        tree_print_compact(root, 0);
    } else if (strcmp(format, "lisp") == 0) {
        tree_print_lisp(root);
        printf("\n");
    } else if (strcmp(format, "lines") == 0) {
        // è¡Œæ ¼å¼
        void print_lines(TreeNode* n, const char* path) {
            char new_path[1024];
            if (path[0] == '\0') {
                snprintf(new_path, sizeof(new_path), "%s", n->value);
            } else {
                snprintf(new_path, sizeof(new_path), "%s/%s", path, n->value);
            }
            printf("%s\n", new_path);
            for (int i = 0; i < n->child_count; i++) {
                print_lines(n->children[i], new_path);
            }
        }
        print_lines(root, "");
    }
}

// éå†æ ‘
void tree_traverse(TreeNode* root, void (*callback)(TreeNode*, int)) {
    void traverse_recursive(TreeNode* node, int depth) {
        if (!node) return;
        callback(node, depth);
        for (int i = 0; i < node->child_count; i++) {
            traverse_recursive(node->children[i], depth + 1);
        }
    }
    traverse_recursive(root, 0);
}

// æŸ¥æ‰¾èŠ‚ç‚¹
TreeNode* tree_find(TreeNode* root, const char* value) {
    if (!root || !value) return NULL;
    
    if (strcmp(root->value, value) == 0) {
        return root;
    }
    
    for (int i = 0; i < root->child_count; i++) {
        TreeNode* found = tree_find(root->children[i], value);
        if (found) return found;
    }
    
    return NULL;
}


3. ä½¿ç”¨ç¤ºä¾‹

// main.c
#include "tree_node.h"

void print_node(TreeNode* node, int depth) {
    for (int i = 0; i < depth; i++) printf("  ");
    printf("Depth %d: %s\n", depth, node->value);
}

int main() {
    printf("=== Cè¯­è¨€æ ‘å½¢æ‰“å°ç¤ºä¾‹ ===\n\n");
    
    // åˆ›å»ºæ ‘ç»“æ„
    TreeNode* root = tree_node_create("project");
    TreeNode* src = tree_node_create("src");
    TreeNode* include = tree_node_create("include");
    TreeNode* tests = tree_node_create("tests");
    TreeNode* docs = tree_node_create("docs");
    
    // æ·»åŠ å­èŠ‚ç‚¹
    tree_node_add_child(root, src);
    tree_node_add_child(root, include);
    tree_node_add_child(root, tests);
    tree_node_add_child(root, docs);
    
    // srcçš„å­èŠ‚ç‚¹
    TreeNode* main_c = tree_node_create("main.c");
    TreeNode* utils_c = tree_node_create("utils.c");
    TreeNode* tree_c = tree_node_create("tree.c");
    tree_node_add_child(src, main_c);
    tree_node_add_child(src, utils_c);
    tree_node_add_child(src, tree_c);
    
    // includeçš„å­èŠ‚ç‚¹
    TreeNode* tree_h = tree_node_create("tree.h");
    TreeNode* utils_h = tree_node_create("utils.h");
    tree_node_add_child(include, tree_h);
    tree_node_add_child(include, utils_h);
    
    // æ‰“å°æ ‘
    printf("1. æ ‘å½¢æ ¼å¼:\n");
    tree_print(root);
    
    printf("\n2. ç´§å‡‘æ ¼å¼:\n");
    tree_print_formatted(root, "compact");
    
    printf("\n3. Lispæ ¼å¼:\n");
    tree_print_formatted(root, "lisp");
    
    printf("\n4. è¡Œæ ¼å¼:\n");
    tree_print_formatted(root, "lines");
    
    printf("\n5. éå†èŠ‚ç‚¹:\n");
    tree_traverse(root, print_node);
    
    // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    printf("\n6. å­—ç¬¦ä¸²å½¢å¼:\n");
    char* tree_str = tree_to_string(root);
    printf("%s", tree_str);
    free(tree_str);
    
    // æŸ¥æ‰¾èŠ‚ç‚¹
    printf("\n7. æŸ¥æ‰¾èŠ‚ç‚¹:\n");
    TreeNode* found = tree_find(root, "utils.c");
    if (found) {
        printf("æ‰¾åˆ°èŠ‚ç‚¹: %s\n", found->value);
    }
    
    // æ¸…ç†å†…å­˜
    tree_node_destroy(root);
    
    return 0;
}


4. ç¼–è¯‘å’Œè¿è¡Œ

# Makefile
CC = gcc
CFLAGS = -Wall -Wextra -std=c99
TARGET = tree_printer
SOURCES = tree_node.c main.c

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) -o $(TARGET) $(SOURCES)

clean:
	rm -f $(TARGET) *.o

run: $(TARGET)
	./$(TARGET)


äºŒã€Goè¯­è¨€ç‰ˆæœ¬

1. å®Œæ•´å®ç°

// tree_printer.go
package main

import (
	"fmt"
	"strings"
	"unicode/utf8"
)

// TreeNode æ ‘èŠ‚ç‚¹å®šä¹‰
type TreeNode struct {
	Value    string
	Children []*TreeNode
}

// NewTreeNode åˆ›å»ºæ–°èŠ‚ç‚¹
func NewTreeNode(value string) *TreeNode {
	return &TreeNode{
		Value:    value,
		Children: make([]*TreeNode, 0),
	}
}

// AddChild æ·»åŠ å­èŠ‚ç‚¹
func (n *TreeNode) AddChild(child *TreeNode) *TreeNode {
	n.Children = append(n.Children, child)
	return n
}

// AddChildren æ‰¹é‡æ·»åŠ å­èŠ‚ç‚¹
func (n *TreeNode) AddChildren(children ...*TreeNode) *TreeNode {
	n.Children = append(n.Children, children...)
	return n
}

// TreePrinter æ ‘æ‰“å°å™¨æ¥å£
type TreePrinter interface {
	Print(root *TreeNode) string
	PrintToStdout(root *TreeNode)
}

// TreeStyle æ ‘æ ·å¼é…ç½®
type TreeStyle struct {
	Vertical   string // å‚ç›´çº¿
	Branch     string // åˆ†æ”¯
	Corner     string // æ‹è§’
	Horizontal string // æ°´å¹³çº¿
	Space      string // ç©ºæ ¼
}

// BasicTreePrinter åŸºç¡€æ ‘æ‰“å°å™¨
type BasicTreePrinter struct {
	Style TreeStyle
}

// DefaultStyle è¿”å›é»˜è®¤æ ·å¼
func DefaultStyle() TreeStyle {
	return TreeStyle{
		Vertical:   "â”‚   ",
		Branch:     "â”œâ”€â”€ ",
		Corner:     "â””â”€â”€ ",
		Horizontal: "â”€â”€â”€ ",
		Space:      "    ",
	}
}

// SimpleStyle è¿”å›ç®€å•æ ·å¼
func SimpleStyle() TreeStyle {
	return TreeStyle{
		Vertical:   "|   ",
		Branch:     "|-- ",
		Corner:     "`-- ",
		Horizontal: "--  ",
		Space:      "    ",
	}
}

// ASCIIArtTreePrinter æ”¯æŒASCIIè‰ºæœ¯çš„æ ‘æ‰“å°å™¨
type ASCIIArtTreePrinter struct {
	Style TreeStyle
	Depth int
}

// Print æ‰“å°æ ‘
func (p *ASCIIArtTreePrinter) Print(root *TreeNode) string {
	if root == nil {
		return ""
	}
	return p.printRecursive(root, "", true)
}

func (p *ASCIIArtTreePrinter) printRecursive(node *TreeNode, prefix string, isLast bool) string {
	var builder strings.Builder
	
	// æ„å»ºå½“å‰è¡Œ
	builder.WriteString(prefix)
	if prefix != "" {
		if isLast {
			builder.WriteString(p.Style.Corner)
		} else {
			builder.WriteString(p.Style.Branch)
		}
	}
	builder.WriteString(node.Value)
	builder.WriteString("\n")
	
	// ä¸ºå­èŠ‚ç‚¹æ„å»ºæ–°å‰ç¼€
	childPrefix := prefix
	if prefix != "" {
		if isLast {
			childPrefix += p.Style.Space
		} else {
			childPrefix += p.Style.Vertical
		}
	}
	
	// é€’å½’æ‰“å°å­èŠ‚ç‚¹
	for i, child := range node.Children {
		isLastChild := i == len(node.Children)-1
		builder.WriteString(p.printRecursive(child, childPrefix, isLastChild))
	}
	
	return builder.String()
}

// PrintToStdout æ‰“å°åˆ°æ ‡å‡†è¾“å‡º
func (p *ASCIIArtTreePrinter) PrintToStdout(root *TreeNode) {
	fmt.Print(p.Print(root))
}

// CompactTreePrinter ç´§å‡‘æ ¼å¼æ‰“å°å™¨
type CompactTreePrinter struct{}

func (p *CompactTreePrinter) Print(root *TreeNode) string {
	var builder strings.Builder
	p.printRecursive(root, 0, &builder)
	return builder.String()
}

func (p *CompactTreePrinter) printRecursive(node *TreeNode, depth int, builder *strings.Builder) {
	indent := strings.Repeat("  ", depth)
	builder.WriteString(fmt.Sprintf("%s- %s\n", indent, node.Value))
	
	for _, child := range node.Children {
		p.printRecursive(child, depth+1, builder)
	}
}

func (p *CompactTreePrinter) PrintToStdout(root *TreeNode) {
	fmt.Print(p.Print(root))
}

// LispStylePrinter Lispé£æ ¼æ‰“å°å™¨
type LispStylePrinter struct{}

func (p *LispStylePrinter) Print(root *TreeNode) string {
	return p.printRecursive(root)
}

func (p *LispStylePrinter) printRecursive(node *TreeNode) string {
	if len(node.Children) == 0 {
		return node.Value
	}
	
	var children []string
	for _, child := range node.Children {
		children = append(children, p.printRecursive(child))
	}
	
	return fmt.Sprintf("(%s %s)", node.Value, strings.Join(children, " "))
}

func (p *LispStylePrinter) PrintToStdout(root *TreeNode) {
	fmt.Println(p.Print(root))
}

// JSONTreePrinter JSONæ ¼å¼æ‰“å°å™¨
type JSONTreePrinter struct{}

func (p *JSONTreePrinter) Print(root *TreeNode) string {
	return p.printRecursive(root, 0)
}

func (p *JSONTreePrinter) printRecursive(node *TreeNode, indent int) string {
	spaces := strings.Repeat("  ", indent)
	
	if len(node.Children) == 0 {
		return fmt.Sprintf(`"%s"`, node.Value)
	}
	
	var childStrs []string
	for _, child := range node.Children {
		childStrs = append(childStrs, p.printRecursive(child, indent+1))
	}
	
	return fmt.Sprintf(`{"%s": [%s%s%s
%s]}`, 
		node.Value, 
		"\n", 
		strings.Join(childStrs, ",\n"),
		"\n"+spaces,
		spaces)
}

func (p *JSONTreePrinter) PrintToStdout(root *TreeNode) {
	fmt.Println(p.Print(root))
}

// TreeBuilder æ ‘æ„å»ºå™¨
type TreeBuilder struct {
	root *TreeNode
}

func NewTreeBuilder(rootValue string) *TreeBuilder {
	return &TreeBuilder{
		root: NewTreeNode(rootValue),
	}
}

func (b *TreeBuilder) AddPath(path ...string) *TreeBuilder {
	current := b.root
	for _, segment := range path {
		found := false
		for _, child := range current.Children {
			if child.Value == segment {
				current = child
				found = true
				break
			}
		}
		if !found {
			newNode := NewTreeNode(segment)
			current.Children = append(current.Children, newNode)
			current = newNode
		}
	}
	return b
}

func (b *TreeBuilder) Build() *TreeNode {
	return b.root
}

// TreeWalker æ ‘éå†å™¨
type TreeWalker struct {
	root *TreeNode
}

func NewTreeWalker(root *TreeNode) *TreeWalker {
	return &TreeWalker{root: root}
}

// WalkDepthFirst æ·±åº¦ä¼˜å…ˆéå†
func (w *TreeWalker) WalkDepthFirst(callback func(*TreeNode, int)) {
	w.walkRecursive(w.root, 0, callback)
}

func (w *TreeWalker) walkRecursive(node *TreeNode, depth int, callback func(*TreeNode, int)) {
	callback(node, depth)
	for _, child := range node.Children {
		w.walkRecursive(child, depth+1, callback)
	}
}

// WalkBreadthFirst å¹¿åº¦ä¼˜å…ˆéå†
func (w *TreeWalker) WalkBreadthFirst(callback func(*TreeNode, int)) {
	queue := []struct {
		node  *TreeNode
		depth int
	}{{w.root, 0}}
	
	for len(queue) > 0 {
		current := queue[0]
		queue = queue[1:]
		
		callback(current.node, current.depth)
		
		for _, child := range current.node.Children {
			queue = append(queue, struct {
				node  *TreeNode
				depth int
			}{child, current.depth + 1})
		}
	}
}

// TreeStats æ ‘ç»Ÿè®¡ä¿¡æ¯
type TreeStats struct {
	TotalNodes  int
	MaxDepth    int
	LeafCount   int
	BranchCount int
}

// GetStats è·å–æ ‘ç»Ÿè®¡ä¿¡æ¯
func (w *TreeWalker) GetStats() TreeStats {
	stats := TreeStats{}
	
	w.WalkDepthFirst(func(node *TreeNode, depth int) {
		stats.TotalNodes++
		stats.MaxDepth = max(stats.MaxDepth, depth)
		
		if len(node.Children) == 0 {
			stats.LeafCount++
		} else {
			stats.BranchCount++
		}
	})
	
	return stats
}

// è¾…åŠ©å‡½æ•°
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// TreeSearch æ ‘æœç´¢
func SearchTree(root *TreeNode, predicate func(*TreeNode) bool) []*TreeNode {
	var results []*TreeNode
	
	walker := NewTreeWalker(root)
	walker.WalkDepthFirst(func(node *TreeNode, depth int) {
		if predicate(node) {
			results = append(results, node)
		}
	})
	
	return results
}

// FindByValue æŒ‰å€¼æŸ¥æ‰¾
func FindByValue(root *TreeNode, value string) *TreeNode {
	results := SearchTree(root, func(node *TreeNode) bool {
		return node.Value == value
	})
	
	if len(results) > 0 {
		return results[0]
	}
	return nil
}


2. ä¸»ç¨‹åºç¤ºä¾‹

// main.go
package main

import (
	"fmt"
	"os"
	"strings"
)

func createSampleTree() *TreeNode {
	// åˆ›å»ºç¤ºä¾‹æ ‘ç»“æ„
	root := NewTreeNode("my-project").
		AddChild(
			NewTreeNode("src").
				AddChildren(
					NewTreeNode("main.go"),
					NewTreeNode("utils.go"),
					NewTreeNode("handlers").
						AddChildren(
							NewTreeNode("user.go"),
							NewTreeNode("auth.go"),
						),
				),
		).
		AddChild(
			NewTreeNode("pkg").
				AddChildren(
					NewTreeNode("math"),
					NewTreeNode("strings"),
				),
		).
		AddChild(
			NewTreeNode("tests").
				AddChildren(
					NewTreeNode("unit"),
					NewTreeNode("integration"),
				),
		).
		AddChild(
			NewTreeNode("docs").
				AddChildren(
					NewTreeNode("README.md"),
					NewTreeNode("API.md"),
				),
		)
	
	return root
}

func demoAllFormats(tree *TreeNode) {
	fmt.Println("=== ä¸åŒæ ¼å¼çš„æ ‘å½¢æ‰“å° ===\n")
	
	fmt.Println("1. æ ‘å½¢æ ¼å¼ (é»˜è®¤æ ·å¼):")
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	printer.PrintToStdout(tree)
	
	fmt.Println("\n2. æ ‘å½¢æ ¼å¼ (ç®€å•æ ·å¼):")
	printer.Style = SimpleStyle()
	printer.PrintToStdout(tree)
	
	fmt.Println("\n3. ç´§å‡‘æ ¼å¼:")
	compactPrinter := &CompactTreePrinter{}
	compactPrinter.PrintToStdout(tree)
	
	fmt.Println("\n4. Lispé£æ ¼:")
	lispPrinter := &LispStylePrinter{}
	lispPrinter.PrintToStdout(tree)
	
	fmt.Println("\n5. JSONæ ¼å¼:")
	jsonPrinter := &JSONTreePrinter{}
	jsonPrinter.PrintToStdout(tree)
}

func demoTreeOperations(tree *TreeNode) {
	fmt.Println("\n=== æ ‘æ“ä½œæ¼”ç¤º ===\n")
	
	// ç»Ÿè®¡ä¿¡æ¯
	walker := NewTreeWalker(tree)
	stats := walker.GetStats()
	fmt.Printf("æ ‘ç»Ÿè®¡ä¿¡æ¯:\n")
	fmt.Printf("  æ€»èŠ‚ç‚¹æ•°: %d\n", stats.TotalNodes)
	fmt.Printf("  æœ€å¤§æ·±åº¦: %d\n", stats.MaxDepth)
	fmt.Printf("  å¶å­èŠ‚ç‚¹: %d\n", stats.LeafCount)
	fmt.Printf("  åˆ†æ”¯èŠ‚ç‚¹: %d\n", stats.BranchCount)
	
	// éå†
	fmt.Println("\næ·±åº¦ä¼˜å…ˆéå†:")
	walker.WalkDepthFirst(func(node *TreeNode, depth int) {
		indent := strings.Repeat("  ", depth)
		fmt.Printf("%s%s (æ·±åº¦: %d)\n", indent, node.Value, depth)
	})
	
	// æœç´¢
	fmt.Println("\næœç´¢åŒ…å« 'go' çš„èŠ‚ç‚¹:")
	goFiles := SearchTree(tree, func(node *TreeNode) bool {
		return strings.Contains(node.Value, ".go")
	})
	for _, file := range goFiles {
		fmt.Printf("  - %s\n", file.Value)
	}
	
	// æŸ¥æ‰¾ç‰¹å®šèŠ‚ç‚¹
	fmt.Println("\næŸ¥æ‰¾èŠ‚ç‚¹ 'handlers':")
	found := FindByValue(tree, "handlers")
	if found != nil {
		fmt.Printf("  æ‰¾åˆ°èŠ‚ç‚¹: %s\n", found.Value)
		fmt.Println("  å…¶å­èŠ‚ç‚¹:")
		for _, child := range found.Children {
			fmt.Printf("    - %s\n", child.Value)
		}
	}
}

func demoTreeBuilder() {
	fmt.Println("\n=== æ ‘æ„å»ºå™¨æ¼”ç¤º ===\n")
	
	builder := NewTreeBuilder("root").
		AddPath("usr", "local", "bin").
		AddPath("usr", "local", "lib").
		AddPath("usr", "share", "man").
		AddPath("var", "log").
		AddPath("var", "cache")
	
	tree := builder.Build()
	
	fmt.Println("ä»è·¯å¾„æ„å»ºçš„æ ‘:")
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	printer.PrintToStdout(tree)
}

func demoCustomTree() {
	fmt.Println("\n=== è‡ªå®šä¹‰æ ‘æ¼”ç¤º ===\n")
	
	// åˆ›å»ºä¸€ä¸ªç»„ç»‡æ¶æ„æ ‘
	ceo := NewTreeNode("CEO: Alice Johnson")
	
	cto := NewTreeNode("CTO: Bob Smith").
		AddChild(
			NewTreeNode("Engineering").
				AddChildren(
					NewTreeNode("Backend Team"),
					NewTreeNode("Frontend Team"),
					NewTreeNode("DevOps"),
				),
		).
		AddChild(
			NewTreeNode("Product").
				AddChildren(
					NewTreeNode("Design"),
					NewTreeNode("Research"),
				),
		)
	
	cfo := NewTreeNode("CFO: Carol White").
		AddChild(
			NewTreeNode("Finance").
				AddChildren(
					NewTreeNode("Accounting"),
					NewTreeNode("Budget"),
				),
		).
		AddChild(
			NewTreeNode("HR").
				AddChildren(
					NewTreeNode("Recruitment"),
					NewTreeNode("Training"),
				),
		)
	
	ceo.AddChildren(cto, cfo)
	
	fmt.Println("ç»„ç»‡æ¶æ„æ ‘:")
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	printer.PrintToStdout(ceo)
}

func saveTreeToFile(tree *TreeNode, filename string) error {
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	treeStr := printer.Print(tree)
	
	return os.WriteFile(filename, []byte(treeStr), 0644)
}

func main() {
	fmt.Println("=== Goè¯­è¨€æ ‘å½¢æ‰“å°ç³»ç»Ÿ ===\n")
	
	// åˆ›å»ºç¤ºä¾‹æ ‘
	tree := createSampleTree()
	
	// æ¼”ç¤ºæ‰€æœ‰æ ¼å¼
	demoAllFormats(tree)
	
	// æ¼”ç¤ºæ ‘æ“ä½œ
	demoTreeOperations(tree)
	
	// æ¼”ç¤ºæ ‘æ„å»ºå™¨
	demoTreeBuilder()
	
	// æ¼”ç¤ºè‡ªå®šä¹‰æ ‘
	demoCustomTree()
	
	// ä¿å­˜åˆ°æ–‡ä»¶
	fmt.Println("\n=== ä¿å­˜åˆ°æ–‡ä»¶ ===")
	err := saveTreeToFile(tree, "tree_output.txt")
	if err != nil {
		fmt.Printf("ä¿å­˜æ–‡ä»¶å¤±è´¥: %v\n", err)
	} else {
		fmt.Println("æ ‘ç»“æ„å·²ä¿å­˜åˆ° tree_output.txt")
	}
	
	// äº¤äº’å¼æ¼”ç¤º
	fmt.Println("\n=== äº¤äº’å¼æ¼”ç¤º ===")
	fmt.Println("è¯·è¾“å…¥æ ‘èŠ‚ç‚¹ï¼Œç”¨ç©ºæ ¼åˆ†éš”ï¼Œç©ºè¡Œç»“æŸ:")
	
	interactiveTree := NewTreeNode("root")
	var input string
	
	for {
		fmt.Print("> ")
		fmt.Scanln(&input)
		if input == "" {
			break
		}
		
		paths := strings.Fields(input)
		for _, path := range paths {
			interactiveTree.AddChild(NewTreeNode(path))
		}
	}
	
	fmt.Println("\nä½ åˆ›å»ºçš„æ ‘:")
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	printer.PrintToStdout(interactiveTree)
}


3. é«˜çº§åŠŸèƒ½æ‰©å±•

// advanced_tree.go
package main

import (
	"fmt"
	"strings"
)

// ColorTreePrinter å½©è‰²æ ‘æ‰“å°å™¨
type ColorTreePrinter struct {
	Style    TreeStyle
	Colors   []string
	MaxDepth int
}

func NewColorTreePrinter() *ColorTreePrinter {
	return &ColorTreePrinter{
		Style: DefaultStyle(),
		Colors: []string{
			"\033[31m", // çº¢è‰²
			"\033[32m", // ç»¿è‰²
			"\033[33m", // é»„è‰²
			"\033[34m", // è“è‰²
			"\033[35m", // ç´«è‰²
			"\033[36m", // é’è‰²
		},
		MaxDepth: 0,
	}
}

func (p *ColorTreePrinter) Print(root *TreeNode) string {
	var builder strings.Builder
	p.printRecursive(root, "", true, 0, &builder)
	return builder.String()
}

func (p *ColorTreePrinter) printRecursive(node *TreeNode, prefix string, isLast bool, depth int, builder *strings.Builder) {
	// é€‰æ‹©é¢œè‰²
	color := ""
	if depth < len(p.Colors) {
		color = p.Colors[depth%len(p.Colors)]
	}
	reset := "\033[0m"
	
	// æ„å»ºå½“å‰è¡Œ
	builder.WriteString(prefix)
	if prefix != "" {
		if isLast {
			builder.WriteString(p.Style.Corner)
		} else {
			builder.WriteString(p.Style.Branch)
		}
	}
	
	builder.WriteString(color)
	builder.WriteString(node.Value)
	builder.WriteString(reset)
	builder.WriteString("\n")
	
	// æ£€æŸ¥æ·±åº¦é™åˆ¶
	if p.MaxDepth > 0 && depth >= p.MaxDepth {
		if len(node.Children) > 0 {
			builder.WriteString(prefix)
			builder.WriteString(p.Style.Space)
			builder.WriteString(fmt.Sprintf("... %d more items\n", len(node.Children)))
		}
		return
	}
	
	// ä¸ºå­èŠ‚ç‚¹æ„å»ºæ–°å‰ç¼€
	childPrefix := prefix
	if prefix != "" {
		if isLast {
			childPrefix += p.Style.Space
		} else {
			childPrefix += p.Style.Vertical
		}
	}
	
	// é€’å½’æ‰“å°å­èŠ‚ç‚¹
	for i, child := range node.Children {
		isLastChild := i == len(node.Children)-1
		p.printRecursive(child, childPrefix, isLastChild, depth+1, builder)
	}
}

// TreeFilter æ ‘è¿‡æ»¤å™¨
type TreeFilter struct {
	Root *TreeNode
}

func NewTreeFilter(root *TreeNode) *TreeFilter {
	return &TreeFilter{Root: root}
}

func (f *TreeFilter) Filter(predicate func(*TreeNode) bool) *TreeNode {
	return f.filterRecursive(f.Root, predicate)
}

func (f *TreeFilter) filterRecursive(node *TreeNode, predicate func(*TreeNode) bool) *TreeNode {
	if node == nil {
		return nil
	}
	
	// å¦‚æœå½“å‰èŠ‚ç‚¹ä¸æ»¡è¶³æ¡ä»¶ï¼Œä½†å¯èƒ½æœ‰å­èŠ‚ç‚¹æ»¡è¶³
	newNode := NewTreeNode(node.Value)
	
	for _, child := range node.Children {
		filteredChild := f.filterRecursive(child, predicate)
		if filteredChild != nil {
			newNode.Children = append(newNode.Children, filteredChild)
		}
	}
	
	// å¦‚æœèŠ‚ç‚¹æ»¡è¶³æ¡ä»¶æˆ–æœ‰å­èŠ‚ç‚¹ï¼Œåˆ™ä¿ç•™
	if predicate(node) || len(newNode.Children) > 0 {
		return newNode
	}
	
	return nil
}

// TreeTransformer æ ‘è½¬æ¢å™¨
type TreeTransformer struct{}

func (t *TreeTransformer) Transform(root *TreeNode, transformFunc func(*TreeNode) *TreeNode) *TreeNode {
	return t.transformRecursive(root, transformFunc)
}

func (t *TreeTransformer) transformRecursive(node *TreeNode, transformFunc func(*TreeNode) *TreeNode) *TreeNode {
	if node == nil {
		return nil
	}
	
	// åº”ç”¨è½¬æ¢å‡½æ•°
	transformed := transformFunc(node)
	if transformed == nil {
		return nil
	}
	
	// é€’å½’è½¬æ¢å­èŠ‚ç‚¹
	for _, child := range node.Children {
		transformedChild := t.transformRecursive(child, transformFunc)
		if transformedChild != nil {
			transformed.Children = append(transformed.Children, transformedChild)
		}
	}
	
	return transformed
}

func mainAdvanced() {
	fmt.Println("=== é«˜çº§æ ‘æ“ä½œæ¼”ç¤º ===\n")
	
	// åˆ›å»ºç¤ºä¾‹æ ‘
	tree := createSampleTree()
	
	// å½©è‰²æ‰“å°
	fmt.Println("1. å½©è‰²æ ‘å½¢æ‰“å°:")
	colorPrinter := NewColorTreePrinter()
	colorPrinter.MaxDepth = 3
	fmt.Println(colorPrinter.Print(tree))
	
	// è¿‡æ»¤æ¼”ç¤º
	fmt.Println("\n2. æ ‘è¿‡æ»¤ (åªæ˜¾ç¤º .go æ–‡ä»¶):")
	filter := NewTreeFilter(tree)
	filtered := filter.Filter(func(node *TreeNode) bool {
		return strings.HasSuffix(node.Value, ".go")
	})
	
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	printer.PrintToStdout(filtered)
	
	// è½¬æ¢æ¼”ç¤º
	fmt.Println("\n3. æ ‘è½¬æ¢ (æ·»åŠ æ–‡ä»¶ç±»å‹å›¾æ ‡):")
	transformer := &TreeTransformer{}
	transformed := transformer.Transform(tree, func(node *TreeNode) *TreeNode {
		newNode := NewTreeNode(node.Value)
		
		// æ ¹æ®æ‰©å±•åæ·»åŠ å›¾æ ‡
		if strings.HasSuffix(node.Value, ".go") {
			newNode.Value = "ğŸ“¦ " + node.Value
		} else if strings.HasSuffix(node.Value, ".md") {
			newNode.Value = "ğŸ“„ " + node.Value
		} else if len(node.Children) > 0 {
			newNode.Value = "ğŸ“ " + node.Value
		} else {
			newNode.Value = "ğŸ“„ " + node.Value
		}
		
		return newNode
	})
	
	printer.PrintToStdout(transformed)
}


4. æµ‹è¯•æ–‡ä»¶

// tree_printer_test.go
package main

import (
	"strings"
	"testing"
)

func TestTreeNodeCreation(t *testing.T) {
	node := NewTreeNode("test")
	if node.Value != "test" {
		t.Errorf("æœŸæœ›å€¼: test, å®é™…å€¼: %s", node.Value)
	}
	if len(node.Children) != 0 {
		t.Errorf("æœŸæœ›å­èŠ‚ç‚¹æ•°: 0, å®é™…: %d", len(node.Children))
	}
}

func TestAddChild(t *testing.T) {
	parent := NewTreeNode("parent")
	child := NewTreeNode("child")
	
	parent.AddChild(child)
	
	if len(parent.Children) != 1 {
		t.Errorf("æœŸæœ›å­èŠ‚ç‚¹æ•°: 1, å®é™…: %d", len(parent.Children))
	}
	if parent.Children[0] != child {
		t.Error("æ·»åŠ çš„å­èŠ‚ç‚¹ä¸æ­£ç¡®")
	}
}

func TestTreePrinting(t *testing.T) {
	root := NewTreeNode("root")
	a := NewTreeNode("A")
	b := NewTreeNode("B")
	
	root.AddChild(a)
	root.AddChild(b)
	
	printer := &ASCIIArtTreePrinter{Style: DefaultStyle()}
	output := printer.Print(root)
	
	if !strings.Contains(output, "root") {
		t.Error("è¾“å‡ºä¸­åº”åŒ…å« 'root'")
	}
	if !strings.Contains(output, "A") {
		t.Error("è¾“å‡ºä¸­åº”åŒ…å« 'A'")
	}
	if !strings.Contains(output, "B") {
		t.Error("è¾“å‡ºä¸­åº”åŒ…å« 'B'")
	}
}

func TestTreeStats(t *testing.T) {
	root := NewTreeNode("root")
	a := NewTreeNode("A")
	b := NewTreeNode("B")
	c := NewTreeNode("C")
	
	root.AddChild(a)
	root.AddChild(b)
	a.AddChild(c)
	
	walker := NewTreeWalker(root)
	stats := walker.GetStats()
	
	if stats.TotalNodes != 4 {
		t.Errorf("æœŸæœ›æ€»èŠ‚ç‚¹æ•°: 4, å®é™…: %d", stats.TotalNodes)
	}
	if stats.LeafCount != 2 {
		t.Errorf("æœŸæœ›å¶å­èŠ‚ç‚¹æ•°: 2, å®é™…: %d", stats.LeafCount)
	}
	if stats.BranchCount != 2 {
		t.Errorf("æœŸæœ›åˆ†æ”¯èŠ‚ç‚¹æ•°: 2, å®é™…: %d", stats.BranchCount)
	}
}

func TestSearchTree(t *testing.T) {
	root := NewTreeNode("root")
	a := NewTreeNode("apple")
	b := NewTreeNode("banana")
	c := NewTreeNode("cherry")
	
	root.AddChild(a)
	root.AddChild(b)
	a.AddChild(c)
	
	results := SearchTree(root, func(node *TreeNode) bool {
		return strings.Contains(node.Value, "a")
	})
	
	if len(results) != 3 { // root, apple, banana
		t.Errorf("æœŸæœ›æ‰¾åˆ°3ä¸ªèŠ‚ç‚¹, å®é™…: %d", len(results))
	}
}


è¿è¡Œè¯´æ˜

Cç‰ˆæœ¬ï¼š

# ç¼–è¯‘
gcc -o tree_printer tree_node.c main.c

# è¿è¡Œ
./tree_printer


Goç‰ˆæœ¬ï¼š

# è¿è¡Œä¸»ç¨‹åº
go run tree_printer.go main.go

# è¿è¡Œé«˜çº§æ¼”ç¤º
go run tree_printer.go advanced_tree.go

# è¿è¡Œæµ‹è¯•
go test -v


è¿™ä¸¤ä¸ªç‰ˆæœ¬éƒ½å®ç°äº†å®Œæ•´çš„æ ‘å½¢æ‰“å°åŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š

1. æ ‘å½¢ç»“æ„æ˜¾ç¤º

2. å¤šç§è¾“å‡ºæ ¼å¼ï¼ˆæ ‘å½¢ã€Lispã€JSONã€ç´§å‡‘æ ¼å¼ç­‰ï¼‰

3. æ ‘éå†å’Œæœç´¢

4. ç»Ÿè®¡ä¿¡æ¯

5. é«˜çº§åŠŸèƒ½ï¼ˆè¿‡æ»¤ã€è½¬æ¢ã€å½©è‰²è¾“å‡ºç­‰ï¼‰

Goç‰ˆæœ¬æ›´å®Œæ•´ï¼ŒåŒ…å«äº†æ›´å¤šç°ä»£ç‰¹æ€§ï¼Œè€ŒCç‰ˆæœ¬æ›´æ³¨é‡åŸºç¡€å®ç°å’Œå†…å­˜ç®¡ç†ã€‚