3é˜¶å¯¼æ•°çš„è‹±æ–‡æ˜¯ third derivativeã€‚

åœ¨æ›´æ­£å¼æˆ–ä¹¦é¢çš„æƒ…å†µä¸‹ï¼Œä½ å¯èƒ½ä¼šçœ‹åˆ°ï¼š

â€¢ Third-order derivative

â€¢  f'''(x)  ï¼ˆå¯¹å‡½æ•°  f(x)  çš„ä¸‰é˜¶å¯¼æ•°ï¼‰

â€¢  \frac{d^3y}{dx^3}  ï¼ˆè±å¸ƒå°¼èŒ¨è®°æ³•ï¼‰

æ›´é«˜é˜¶çš„å¯¼æ•°ï¼ˆné˜¶ï¼‰é€šå¸¸ç§°ä¸º nth derivative æˆ– nth-order derivativeã€‚
//compl
package main

import (
	"bufio"
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"
)

// ğŸ›ï¸ æ¸¸æˆå¸¸é‡
const (
	MAP_WIDTH    = 20
	MAP_HEIGHT   = 15
	MAX_PLAYERS  = 8
	START_YEAR   = 4000 // å…¬å…ƒå‰4000å¹´
	END_YEAR     = 2050 // æ¸¸æˆç»“æŸå¹´ä»½
)

// ğŸŒ åœ°å½¢ç±»å‹
type TerrainType int

const (
	TERRAIN_OCEAN TerrainType = iota
	TERRAIN_PLAINS
	TERRAIN_DESERT
	TERRAIN_MOUNTAINS
	TERRAIN_FOREST
	TERRAIN_HILLS
	TERRAIN_TUNDRA
	TERRAIN_JUNGLE
)

// ğŸ›ï¸ å»ºç­‘ç±»å‹
type BuildingType int

const (
	BUILDING_MONUMENT BuildingType = iota
	BUILDING_GRANARY
	BUILDING_LIBRARY
	BUILDING_TEMPLE
	BUILDING_BARRACKS
	BUILDING_WALLS
	BUILDING_UNIVERSITY
	BUILDING_FACTORY
)

// ğŸ”¬ ç§‘æŠ€ç±»å‹
type TechType int

const (
	TECH_AGRICULTURE TechType = iota
	TECH_POTTERY
	TECH_WRITING
	TECH_MATHEMATICS
	TECH_CONSTRUCTION
	TECH_PHILOSOPHY
	TECH_ENGINEERING
	TECH_EDUCATION
	TECH_GUNPOWDER
	TECH_INDUSTRIALIZATION
)

// âš”ï¸ å•ä½ç±»å‹
type UnitType int

const (
	UNIT_SETTLER UnitType = iota
	UNIT_WARRIOR
	UNIT_ARCHER
	UNIT_SWORDSMAN
	UNIT_KNIGHT
	UNIT_MUSKETEER
	UNIT_CANNON
	UNIT_TANK
)

// ğŸ›ï¸ æ–‡æ˜ç±»å‹
type CivilizationType int

const (
	CIV_EGYPT CivilizationType = iota
	CIV_GREECE
	CIV_ROME
	CIV_CHINA
	CIV_PERSIA
	CIV_INCA
	CIV_ENGLAND
	CIV_FRANCE
)

// ğŸ›ï¸ åŸå¸‚ç»“æ„
type City struct {
	Name          string
	Population    int
	Production    int
	Food          int
	Buildings     []BuildingType
	ProductionQueue []interface{} // å¯ä»¥æ˜¯UnitTypeæˆ–BuildingType
}

// ğŸŒ åœ°å›¾å•å…ƒæ ¼
type Tile struct {
	Terrain  TerrainType
	Resource string
	Improved bool // æ˜¯å¦è¢«æ”¹è‰¯
	City     *City
	Unit     *Unit
	Owner    *Player
}

// âš”ï¸ å•ä½ç»“æ„
type Unit struct {
	Type       UnitType
	Health     int
	Movement   int
	Strength   int
	Experience int
}

// ğŸ›ï¸ ç©å®¶ç»“æ„
type Player struct {
	Name         string
	CivType      CivilizationType
	Cities       []*City
	Units        []*Unit
	Techs        map[TechType]bool
	Researching  TechType
	Gold         int
	Happiness    int
	IsAI         bool
	Relations    map[*Player]int // ä¸å…¶ä»–ç©å®¶çš„å…³ç³» (-100åˆ°100)
}

// ğŸ® æ¸¸æˆçŠ¶æ€
type Game struct {
	Year               int
	Map                [][]Tile
	Players            []*Player
	CurrentPlayerIndex int
	Winner             *Player
}

// ğŸŒ ç”Ÿæˆåœ°å›¾
func (g *Game) generateMap() {
	g.Map = make([][]Tile, MAP_HEIGHT)
	for y := 0; y < MAP_HEIGHT; y++ {
		g.Map[y] = make([]Tile, MAP_WIDTH)
		for x := 0; x < MAP_WIDTH; x++ {
			// éšæœºåœ°å½¢
			terrain := TerrainType(rand.Intn(8))

			// æ·»åŠ èµ„æº
			resources := []string{"", "Wheat", "Fish", "Gold", "Iron", "Horses"}
			resource := ""
			if rand.Intn(10) == 0 { // 10%å‡ ç‡æœ‰èµ„æº
				resource = resources[rand.Intn(len(resources))]
			}

			g.Map[y][x] = Tile{
				Terrain:  terrain,
				Resource: resource,
			}
		}
	}
}

// ğŸ›ï¸ åˆ›å»ºç©å®¶
func (g *Game) createPlayers(numPlayers int) {
	civNames := []string{
		"åŸƒåŠ", "å¸Œè…Š", "ç½—é©¬", "ä¸­å›½", "æ³¢æ–¯", "å°åŠ ", "è‹±æ ¼å…°", "æ³•å›½",
	}

	for i := 0; i < numPlayers; i++ {
		player := &Player{
			Name:        civNames[i],
			CivType:     CivilizationType(i),
			Techs:       make(map[TechType]bool),
			Gold:        100,
			Happiness:   100,
			IsAI:        i > 0, // ç¬¬ä¸€ä¸ªç©å®¶æ˜¯äººç±»
			Relations:   make(map[*Player]int),
		}

		// åˆå§‹ç§‘æŠ€
		player.Techs[TECH_AGRICULTURE] = true
		player.Researching = TECH_POTTERY

		// éšæœºä½ç½®å»ºç«‹é¦–éƒ½
		x, y := rand.Intn(MAP_WIDTH), rand.Intn(MAP_HEIGHT)
		for g.Map[y][x].Terrain == TERRAIN_OCEAN || g.Map[y][x].Terrain == TERRAIN_MOUNTAINS {
			x, y = rand.Intn(MAP_WIDTH), rand.Intn(MAP_HEIGHT)
		}

		capital := &City{
			Name:       player.Name + "é¦–éƒ½",
			Population: 1,
		}
		player.Cities = append(player.Cities, capital)
		g.Map[y][x].City = capital
		g.Map[y][x].Owner = player

		// åˆå§‹å•ä½
		settler := &Unit{Type: UNIT_SETTLER, Health: 100, Movement: 2}
		warrior := &Unit{Type: UNIT_WARRIOR, Health: 100, Movement: 2, Strength: 10}
		player.Units = append(player.Units, settler, warrior)
		g.Map[y][x].Unit = settler

		// æ”¾ç½®æˆ˜å£«åœ¨é™„è¿‘
		nearX, nearY := (x+1)%MAP_WIDTH, y
		g.Map[nearY][nearX].Unit = warrior

		g.Players = append(g.Players, player)
	}
}

// ğŸ›ï¸ åˆå§‹åŒ–æ¸¸æˆ
func NewGame(numPlayers int) *Game {
	rand.Seed(time.Now().UnixNano())

	game := &Game{
		Year: START_YEAR,
	}

	game.generateMap()
	game.createPlayers(numPlayers)

	return game
}

// ğŸ® ä¸»æ¸¸æˆå¾ªç¯
func (g *Game) Run() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("ğŸ›ï¸ æ¬¢è¿æ¥åˆ°æ–‡æ˜æ¸¸æˆ!")
	fmt.Println("ä½ å°†å¸¦é¢†ä¸€ä¸ªæ–‡æ˜ä»å¤ä»£èµ°å‘ç°ä»£")

	for {
		// æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
		if g.checkGameOver() {
			g.displayWinner()
			return
		}

		// è·å–å½“å‰ç©å®¶
		currentPlayer := g.Players[g.CurrentPlayerIndex]

		fmt.Printf("\n======= %s çš„å›åˆ (å¹´ä»½: %d BC) =======\n", currentPlayer.Name, g.Year)

		if currentPlayer.IsAI {
			g.aiTurn(currentPlayer)
		} else {
			g.playerTurn(currentPlayer)
		}

		// ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç©å®¶
		g.CurrentPlayerIndex = (g.CurrentPlayerIndex + 1) % len(g.Players)

		// æ‰€æœ‰ç©å®¶å®Œæˆå›åˆåæ¨è¿›æ—¶é—´
		if g.CurrentPlayerIndex == 0 {
			g.endTurn()
		}
	}
}

// ğŸ“… ç»“æŸå›åˆ
func (g *Game) endTurn() {
	g.Year += 10 // æ¯å›åˆæ¨è¿›10å¹´

	// æ›´æ–°æ‰€æœ‰ç©å®¶çŠ¶æ€
	for _, player := range g.Players {
		// åŸå¸‚å¢é•¿
		for _, city := range player.Cities {
			city.Population += rand.Intn(2) // éšæœºå¢é•¿
			city.Food += city.Population * 2 // ç”Ÿäº§é£Ÿç‰©

			// å¤„ç†ç”Ÿäº§é˜Ÿåˆ—
			if len(city.ProductionQueue) > 0 {
				item := city.ProductionQueue[0]
				switch v := item.(type) {
				case UnitType:
					city.Production -= 10
					if city.Production <= 0 {
						// ç”Ÿäº§å®Œæˆ
						unit := &Unit{Type: v}
						switch v {
						case UNIT_SETTLER:
							unit.Movement = 2
						case UNIT_WARRIOR:
							unit.Movement = 2
							unit.Strength = 10
						}
						player.Units = append(player.Units, unit)
						city.ProductionQueue = city.ProductionQueue[1:]
						fmt.Printf("ğŸ­ %s ç”Ÿäº§äº† %s\n", city.Name, unitTypeToString(v))
					}
				case BuildingType:
					city.Production -= 5
					if city.Production <= 0 {
						city.Buildings = append(city.Buildings, v)
						city.ProductionQueue = city.ProductionQueue[1:]
						fmt.Printf("ğŸ—ï¸ %s å»ºé€ äº† %s\n", city.Name, buildingTypeToString(v))
					}
				}
			}
		}

		// ç§‘æŠ€ç ”ç©¶
		if rand.Intn(100) < 30 { // 30%å‡ ç‡å®Œæˆç ”ç©¶
			player.Techs[player.Researching] = true
			fmt.Printf("ğŸ”¬ %s ç ”ç©¶å®Œæˆ: %s\n", player.Name, techTypeToString(player.Researching))
			player.Researching = TechType((int(player.Researching) + 1) % 10)
		}
	}

	fmt.Printf("\nğŸ“… å¹´ä»½æ¨è¿›è‡³ %d BC\n", g.Year)
}

// ğŸ† æ£€æŸ¥æ¸¸æˆç»“æŸ
func (g *Game) checkGameOver() bool {
	// æ—¶é—´ç»“æŸ
	if g.Year >= END_YEAR {
		// æŒ‰åˆ†æ•°å†³å®šèƒœåˆ©è€…
		highestScore := 0
		var winner *Player
		for _, player := range g.Players {
			score := g.calculateScore(player)
			if score > highestScore {
				highestScore = score
				winner = player
			}
		}
		g.Winner = winner
		return true
	}

	// å¾æœèƒœåˆ©
	for _, player := range g.Players {
		if len(player.Cities) == 0 {
			continue // å·²è¢«æ¶ˆç­
		}

		allConquered := true
		for _, other := range g.Players {
			if other != player && len(other.Cities) > 0 {
				allConquered = false
				break
			}
		}

		if allConquered {
			g.Winner = player
			return true
		}
	}

	return false
}

// ğŸ† æ˜¾ç¤ºèƒœåˆ©è€…
func (g *Game) displayWinner() {
	fmt.Println("\nğŸ†ğŸ†ğŸ† æ¸¸æˆç»“æŸ! ğŸ†ğŸ†ğŸ†")
	fmt.Printf("ğŸ‰ èƒœåˆ©è€…: %s\n", g.Winner.Name)
	fmt.Printf("å¹´ä»½: %d BC | åŸå¸‚: %d | ç§‘æŠ€: %d\n",
		g.Year, len(g.Winner.Cities), len(g.Winner.Techs))

	// æ˜¾ç¤ºåˆ†æ•°
	fmt.Println("\nğŸ“Š æœ€ç»ˆåˆ†æ•°:")
	for _, player := range g.Players {
		score := g.calculateScore(player)
		fmt.Printf("- %s: %dåˆ†\n", player.Name, score)
	}
}

// ğŸ§® è®¡ç®—åˆ†æ•°
func (g *Game) calculateScore(player *Player) int {
	score := 0

	// åŸå¸‚åˆ†æ•°
	score += len(player.Cities) * 100

	// ç§‘æŠ€åˆ†æ•°
	score += len(player.Techs) * 50

	// é¢†åœŸåˆ†æ•°
	for y := 0; y < MAP_HEIGHT; y++ {
		for x := 0; x < MAP_WIDTH; x++ {
			if g.Map[y][x].Owner == player {
				score += 5
			}
		}
	}

	return score
}

// ğŸ¤– AIç©å®¶å›åˆ
func (g *Game) aiTurn(player *Player) {
	fmt.Printf("\nğŸ¤– %s çš„å›åˆ\n", player.Name)

	// ç®€å•AIç­–ç•¥
	for _, city := range player.Cities {
		// éšæœºç”Ÿäº§å•ä½æˆ–å»ºç­‘
		if len(city.ProductionQueue) == 0 {
			if rand.Intn(2) == 0 {
				// ç”Ÿäº§å•ä½
				unitTypes := []UnitType{UNIT_WARRIOR, UNIT_ARCHER, UNIT_SETTLER}
				city.ProductionQueue = append(city.ProductionQueue, unitTypes[rand.Intn(len(unitTypes))])
				city.Production = 100
			} else {
				// å»ºé€ å»ºç­‘
				buildingTypes := []BuildingType{BUILDING_GRANARY, BUILDING_MONUMENT, BUILDING_BARRACKS}
				city.ProductionQueue = append(city.ProductionQueue, buildingTypes[rand.Intn(len(buildingTypes))])
				city.Production = 50
			}
		}
	}

	// ç§»åŠ¨å•ä½
	for _, unit := range player.Units {
		// å¯»æ‰¾å•ä½ä½ç½®
		var x, y int
		for y = 0; y < MAP_HEIGHT; y++ {
			for x = 0; x < MAP_WIDTH; x++ {
				if g.Map[y][x].Unit == unit {
					goto found
				}
			}
		}
	found:

		// éšæœºç§»åŠ¨
		dx, dy := rand.Intn(3)-1, rand.Intn(3)-1
		newX, newY := (x+dx+MAP_WIDTH)%MAP_WIDTH, (y+dy+MAP_HEIGHT)%MAP_HEIGHT

		// æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨
		if g.Map[newY][newX].Terrain != TERRAIN_OCEAN && g.Map[newY][newX].Terrain != TERRAIN_MOUNTAINS {
			if g.Map[newY][newX].Unit == nil {
				// ç§»åŠ¨å•ä½
				g.Map[y][x].Unit = nil
				g.Map[newY][newX].Unit = unit
				fmt.Printf("ğŸš¶ %s å•ä½ç§»åŠ¨åˆ° (%d,%d)\n", player.Name, newX, newY)
			} else if g.Map[newY][newX].Owner != player {
				// æ”»å‡»
				fmt.Printf("âš”ï¸ %s å•ä½æ”»å‡» (%d,%d)\n", player.Name, newX, newY)
				if rand.Intn(100) < 70 { // 70%èƒœç‡
					// è·èƒœ
					g.Map[newY][newX].Unit = nil
					g.Map[newY][newX].Owner = player
					fmt.Printf("âœ… æ”»å‡»æˆåŠŸ! å é¢† (%d,%d)\n", newX, newY)
				} else {
					// å¤±è´¥
					g.Map[y][x].Unit = nil
					fmt.Printf("âŒ æ”»å‡»å¤±è´¥! å•ä½è¢«æ¶ˆç­\n")
				}
			}
		}
	}

	fmt.Println("ğŸ¤– ç»“æŸå›åˆ")
}

// ğŸ® ç©å®¶å›åˆ
func (g *Game) playerTurn(player *Player) {
	reader := bufio.NewReader(os.Stdin)

	for {
		fmt.Println("\nğŸ® è¯·é€‰æ‹©è¡ŒåŠ¨:")
		fmt.Println("1. ç®¡ç†åŸå¸‚")
		fmt.Println("2. ç§»åŠ¨å•ä½")
		fmt.Println("3. å»ºç«‹åŸå¸‚")
		fmt.Println("4. ç ”ç©¶ç§‘æŠ€")
		fmt.Println("5. å¤–äº¤å…³ç³»")
		fmt.Println("6. æŸ¥çœ‹åœ°å›¾")
		fmt.Println("7. æŸ¥çœ‹çŠ¶æ€")
		fmt.Println("8. ç»“æŸå›åˆ")

		fmt.Print("è¯·è¾“å…¥é€‰é¡¹: ")
		input, _ := reader.ReadString('\n')
		choice, err := strconv.Atoi(strings.TrimSpace(input))
		if err != nil {
			fmt.Println("æ— æ•ˆè¾“å…¥")
			continue
		}

		switch choice {
		case 1:
			g.manageCities(player)
		case 2:
			g.moveUnits(player)
		case 3:
			g.foundCity(player)
		case 4:
			g.researchTech(player)
		case 5:
			g.diplomacy(player)
		case 6:
			g.displayMap()
		case 7:
			g.displayStatus(player)
		case 8:
			fmt.Println("ç»“æŸå›åˆ")
			return
		default:
			fmt.Println("æ— æ•ˆé€‰é¡¹")
		}
	}
}

// ğŸ™ï¸ ç®¡ç†åŸå¸‚
func (g *Game) manageCities(player *Player) {
	reader := bufio.NewReader(os.Stdin)

	if len(player.Cities) == 0 {
		fmt.Println("ä½ æ²¡æœ‰åŸå¸‚")
		return
	}

	// é€‰æ‹©åŸå¸‚
	fmt.Println("\nğŸ™ï¸ ä½ çš„åŸå¸‚:")
	for i, city := range player.Cities {
		fmt.Printf("%d. %s (äººå£: %d)\n", i+1, city.Name, city.Population)
	}

	fmt.Print("é€‰æ‹©åŸå¸‚ç¼–å·: ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(player.Cities) {
		fmt.Println("æ— æ•ˆé€‰æ‹©")
		return
	}

	city := player.Cities[index-1]

	// åŸå¸‚ç®¡ç†èœå•
	for {
		fmt.Printf("\nğŸ™ï¸ ç®¡ç†åŸå¸‚: %s\n", city.Name)
		fmt.Println("1. æŸ¥çœ‹ä¿¡æ¯")
		fmt.Println("2. ç”Ÿäº§å•ä½")
		fmt.Println("3. å»ºé€ å»ºç­‘")
		fmt.Println("4. è¿”å›")

		fmt.Print("è¯·è¾“å…¥é€‰é¡¹: ")
		input, _ := reader.ReadString('\n')
		choice, err := strconv.Atoi(strings.TrimSpace(input))
		if err != nil {
			fmt.Println("æ— æ•ˆè¾“å…¥")
			continue
		}

		switch choice {
		case 1:
			g.displayCityInfo(city)
		case 2:
			g.produceUnit(city)
		case 3:
			g.buildBuilding(city)
		case 4:
			return
		default:
			fmt.Println("æ— æ•ˆé€‰é¡¹")
		}
	}
}

// ğŸš¶ ç§»åŠ¨å•ä½
func (g *Game) moveUnits(player *Player) {
	reader := bufio.NewReader(os.Stdin)

	if len(player.Units) == 0 {
		fmt.Println("ä½ æ²¡æœ‰å•ä½")
		return
	}

	// é€‰æ‹©å•ä½
	fmt.Println("\nğŸš¶ ä½ çš„å•ä½:")
	for i, unit := range player.Units {
		fmt.Printf("%d. %s\n", i+1, unitTypeToString(unit.Type))
	}

	fmt.Print("é€‰æ‹©å•ä½ç¼–å·: ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(player.Units) {
		fmt.Println("æ— æ•ˆé€‰æ‹©")
		return
	}

	unit := player.Units[index-1]

	// å¯»æ‰¾å•ä½ä½ç½®
	var x, y int
	for y = 0; y < MAP_HEIGHT; y++ {
		for x = 0; x < MAP_WIDTH; x++ {
			if g.Map[y][x].Unit == unit {
				goto found
			}
		}
	}
	fmt.Println("å•ä½æœªåœ¨åœ°å›¾ä¸Š")
	return

found:
	fmt.Printf("å•ä½ä½ç½®: (%d,%d)\n", x, y)
	fmt.Print("è¾“å…¥ç§»åŠ¨æ–¹å‘ (wä¸Š, sä¸‹, aå·¦, då³): ")
	input, _ = reader.ReadString('\n')
	direction := strings.TrimSpace(input)

	dx, dy := 0, 0
	switch direction {
	case "w":
		dy = -1
	case "s":
		dy = 1
	case "a":
		dx = -1
	case "d":
		dx = 1
	default:
		fmt.Println("æ— æ•ˆæ–¹å‘")
		return
	}

	newX, newY := (x+dx+MAP_WIDTH)%MAP_WIDTH, (y+dy+MAP_HEIGHT)%MAP_HEIGHT

	// æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨
	if g.Map[newY][newX].Terrain == TERRAIN_OCEAN || g.Map[newY][newX].Terrain == TERRAIN_MOUNTAINS {
		fmt.Println("æ— æ³•ç§»åŠ¨åˆ°è¯¥åœ°å½¢")
		return
	}

	if g.Map[newY][newX].Unit != nil {
		if g.Map[newY][newX].Owner == player {
			fmt.Println("è¯¥ä½ç½®å·²æœ‰å‹æ–¹å•ä½")
			return
		} else {
			// æ”»å‡»
			fmt.Printf("âš”ï¸ æ”»å‡» (%d,%d) çš„å•ä½\n", newX, newY)
			if rand.Intn(100) < 70 { // 70%èƒœç‡
				// è·èƒœ
				g.Map[newY][newX].Unit = nil
				g.Map[newY][newX].Owner = player
				fmt.Printf("âœ… æ”»å‡»æˆåŠŸ! å é¢† (%d,%d)\n", newX, newY)
			} else {
				// å¤±è´¥
				g.Map[y][x].Unit = nil
				fmt.Printf("âŒ æ”»å‡»å¤±è´¥! å•ä½è¢«æ¶ˆç­\n")
			}
			return
		}
	}

	// ç§»åŠ¨å•ä½
	g.Map[y][x].Unit = nil
	g.Map[newY][newX].Unit = unit
	fmt.Printf("âœ… å•ä½ç§»åŠ¨åˆ° (%d,%d)\n", newX, newY)
}

// ğŸ™ï¸ å»ºç«‹åŸå¸‚
func (g *Game) foundCity(player *Player) {
	reader := bufio.NewReader(os.Stdin)

	// å¯»æ‰¾å®šå±…è€…
	var settler *Unit
	for _, unit := range player.Units {
		if unit.Type == UNIT_SETTLER {
			settler = unit
			break
		}
	}

	if settler == nil {
		fmt.Println("æ²¡æœ‰å¯ç”¨çš„å®šå±…è€…")
		return
	}

	// å¯»æ‰¾å®šå±…è€…ä½ç½®
	var x, y int
	for y = 0; y < MAP_HEIGHT; y++ {
		for x = 0; x < MAP_WIDTH; x++ {
			if g.Map[y][x].Unit == settler {
				goto found
			}
		}
	}
	fmt.Println("å®šå±…è€…æœªåœ¨åœ°å›¾ä¸Š")
	return

found:
	// æ£€æŸ¥æ˜¯å¦å¯ä»¥å»ºç«‹åŸå¸‚
	if g.Map[y][x].City != nil {
		fmt.Println("è¯¥ä½ç½®å·²æœ‰åŸå¸‚")
		return
	}

	fmt.Print("è¾“å…¥æ–°åŸå¸‚åç§°: ")
	name, _ := reader.ReadString('\n')
	name = strings.TrimSpace(name)

	// å»ºç«‹åŸå¸‚
	city := &City{
		Name:       name,
		Population: 1,
	}
	player.Cities = append(player.Cities, city)
	g.Map[y][x].City = city
	g.Map[y][x].Owner = player
	g.Map[y][x].Unit = nil // å®šå±…è€…æ¶ˆå¤±

	// ç§»é™¤å®šå±…è€…
	for i, unit := range player.Units {
		if unit == settler {
			player.Units = append(player.Units[:i], player.Units[i+1:]...)
			break
		}
	}

	fmt.Printf("ğŸ™ï¸ å»ºç«‹äº†æ–°åŸå¸‚: %s\n", name)
}

// ğŸ”¬ ç ”ç©¶ç§‘æŠ€
func (g *Game) researchTech(player *Player) {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("\nğŸ”¬ å¯ç ”ç©¶çš„ç§‘æŠ€:")
	techs := []TechType{
		TECH_POTTERY,
		TECH_WRITING,
		TECH_MATHEMATICS,
		TECH_CONSTRUCTION,
		TECH_PHILOSOPHY,
		TECH_ENGINEERING,
		TECH_EDUCATION,
		TECH_GUNPOWDER,
		TECH_INDUSTRIALIZATION,
	}

	for i, tech := range techs {
		if !player.Techs[tech] {
			fmt.Printf("%d. %s\n", i+1, techTypeToString(tech))
		}
	}

	fmt.Print("é€‰æ‹©è¦ç ”ç©¶çš„ç§‘æŠ€ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(techs) {
		fmt.Println("å–æ¶ˆç ”ç©¶")
		return
	}

	tech := techs[index-1]
	player.Researching = tech
	fmt.Printf("ğŸ”¬ å¼€å§‹ç ”ç©¶: %s\n", techTypeToString(tech))
}

// ğŸ¤ å¤–äº¤å…³ç³»
func (g *Game) diplomacy(player *Player) {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("\nğŸ¤ å¤–äº¤å…³ç³»:")
	for i, other := range g.Players {
		if other != player {
			relation := player.Relations[other]
			status := "ä¸­ç«‹"
			if relation > 50 {
				status = "å‹å¥½"
			} else if relation < -50 {
				status = "æ•Œå¯¹"
			}
			fmt.Printf("%d. %s: %s (%d)\n", i+1, other.Name, status, relation)
		}
	}

	fmt.Print("é€‰æ‹©å¤–äº¤å¯¹è±¡ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(g.Players)-1 {
		fmt.Println("å–æ¶ˆå¤–äº¤")
		return
	}

	// è·å–ç›®æ ‡ç©å®¶
	targetIndex := index
	if targetIndex >= playerIndex(g, player) {
		targetIndex++ // è·³è¿‡è‡ªå·±
	}
	target := g.Players[targetIndex-1]

	// å¤–äº¤è¡ŒåŠ¨
	fmt.Println("\nå¤–äº¤è¡ŒåŠ¨:")
	fmt.Println("1. å®£æˆ˜")
	fmt.Println("2. å’Œå¹³åè®®")
	fmt.Println("3. è´¸æ˜“åå®š")
	fmt.Println("4. è¿”å›")

	fmt.Print("è¯·é€‰æ‹©è¡ŒåŠ¨: ")
	input, _ = reader.ReadString('\n')
	action, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil {
		return
	}

	switch action {
	case 1:
		player.Relations[target] = -100
		fmt.Printf("âš”ï¸ å‘ %s å®£æˆ˜!\n", target.Name)
	case 2:
		player.Relations[target] = 50
		fmt.Printf("ğŸ•Šï¸ ä¸ %s ç­¾è®¢å’Œå¹³åè®®\n", target.Name)
	case 3:
		player.Relations[target] += 20
		fmt.Printf("ğŸ¤ ä¸ %s ç­¾è®¢è´¸æ˜“åå®š\n", target.Name)
	}
}

// ğŸ—ºï¸ æ˜¾ç¤ºåœ°å›¾
func (g *Game) displayMap() {
	fmt.Println("\nğŸ—ºï¸ ä¸–ç•Œåœ°å›¾:")

	for y := 0; y < MAP_HEIGHT; y++ {
		for x := 0; x < MAP_WIDTH; x++ {
			tile := g.Map[y][x]

			// æ˜¾ç¤ºç¬¦å·
			symbol := ""
			switch tile.Terrain {
			case TERRAIN_OCEAN:
				symbol = "ğŸŒŠ"
			case TERRAIN_PLAINS:
				symbol = "ğŸŒ¾"
			case TERRAIN_DESERT:
				symbol = "ğŸœï¸"
			case TERRAIN_MOUNTAINS:
				symbol = "â›°ï¸"
			case TERRAIN_FOREST:
				symbol = "ğŸŒ²"
			case TERRAIN_HILLS:
				symbol = "ğŸï¸"
			case TERRAIN_TUNDRA:
				symbol = "â„ï¸"
			case TERRAIN_JUNGLE:
				symbol = "ğŸŒ´"
			}

			// æ˜¾ç¤ºåŸå¸‚
			if tile.City != nil {
				symbol = "ğŸ™ï¸"
			}

			// æ˜¾ç¤ºå•ä½
			if tile.Unit != nil {
				switch tile.Unit.Type {
				case UNIT_SETTLER:
					symbol = "ğŸ‘¨â€ğŸŒ¾"
				case UNIT_WARRIOR:
					symbol = "âš”ï¸"
				case UNIT_ARCHER:
					symbol = "ğŸ¹"
				case UNIT_SWORDSMAN:
					symbol = "ğŸ—¡ï¸"
				case UNIT_KNIGHT:
					symbol = "ğŸ"
				}
			}

			fmt.Print(symbol)
		}
		fmt.Println()
	}
}

// ğŸ“Š æ˜¾ç¤ºç©å®¶çŠ¶æ€
func (g *Game) displayStatus(player *Player) {
	fmt.Printf("\nğŸ“Š %s çš„çŠ¶æ€\n", player.Name)
	fmt.Printf("å¹´ä»½: %d BC\n", g.Year)
	fmt.Printf("é»„é‡‘: %d\n", player.Gold)
	fmt.Printf("å¿«ä¹åº¦: %d\n", player.Happiness)
	fmt.Printf("ç ”ç©¶ä¸­çš„ç§‘æŠ€: %s\n", techTypeToString(player.Researching))

	fmt.Println("\nğŸ™ï¸ åŸå¸‚:")
	for _, city := range player.Cities {
		fmt.Printf("- %s (äººå£: %d)\n", city.Name, city.Population)
	}

	fmt.Println("\nğŸ”¬ å·²æŒæ¡çš„ç§‘æŠ€:")
	for tech := range player.Techs {
		fmt.Printf("- %s\n", techTypeToString(tech))
	}
}

// ğŸ™ï¸ æ˜¾ç¤ºåŸå¸‚ä¿¡æ¯
func (g *Game) displayCityInfo(city *City) {
	fmt.Printf("\nğŸ™ï¸ åŸå¸‚: %s\n", city.Name)
	fmt.Printf("äººå£: %d\n", city.Population)
	fmt.Printf("é£Ÿç‰©: %d\n", city.Food)
	fmt.Printf("ç”Ÿäº§åŠ›: %d\n", city.Production)

	fmt.Println("\nğŸ—ï¸ å»ºç­‘:")
	for _, building := range city.Buildings {
		fmt.Printf("- %s\n", buildingTypeToString(building))
	}

	fmt.Println("\nğŸ­ ç”Ÿäº§é˜Ÿåˆ—:")
	for _, item := range city.ProductionQueue {
		switch v := item.(type) {
		case UnitType:
			fmt.Printf("- %s\n", unitTypeToString(v))
		case BuildingType:
			fmt.Printf("- %s\n", buildingTypeToString(v))
		}
	}
}

// âš”ï¸ ç”Ÿäº§å•ä½
func (g *Game) produceUnit(city *City) {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("\nâš”ï¸ å¯ç”Ÿäº§çš„å•ä½:")
	units := []UnitType{
		UNIT_SETTLER,
		UNIT_WARRIOR,
		UNIT_ARCHER,
		UNIT_SWORDSMAN,
		UNIT_KNIGHT,
	}

	for i, unit := range units {
		fmt.Printf("%d. %s\n", i+1, unitTypeToString(unit))
	}

	fmt.Print("é€‰æ‹©å•ä½ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(units) {
		fmt.Println("å–æ¶ˆç”Ÿäº§")
		return
	}

	city.ProductionQueue = append(city.ProductionQueue, units[index-1])
	city.Production = 100
	fmt.Printf("ğŸ­ å¼€å§‹ç”Ÿäº§: %s\n", unitTypeToString(units[index-1]))
}

// ğŸ—ï¸ å»ºé€ å»ºç­‘
func (g *Game) buildBuilding(city *City) {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("\nğŸ—ï¸ å¯å»ºé€ çš„å»ºç­‘:")
	buildings := []BuildingType{
		BUILDING_MONUMENT,
		BUILDING_GRANARY,
		BUILDING_LIBRARY,
		BUILDING_TEMPLE,
		BUILDING_BARRACKS,
	}

	for i, building := range buildings {
		fmt.Printf("%d. %s\n", i+1, buildingTypeToString(building))
	}

	fmt.Print("é€‰æ‹©å»ºç­‘ç¼–å· (0å–æ¶ˆ): ")
	input, _ := reader.ReadString('\n')
	index, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || index < 1 || index > len(buildings) {
		fmt.Println("å–æ¶ˆå»ºé€ ")
		return
	}

	city.ProductionQueue = append(city.ProductionQueue, buildings[index-1])
	city.Production = 50
	fmt.Printf("ğŸ—ï¸ å¼€å§‹å»ºé€ : %s\n", buildingTypeToString(buildings[index-1]))
}

// ğŸ§ª åœ°å½¢ç±»å‹è½¬å­—ç¬¦ä¸²
func terrainTypeToString(terrain TerrainType) string {
	names := []string{
		"æµ·æ´‹", "å¹³åŸ", "æ²™æ¼ ", "å±±è„‰", "æ£®æ—", "ä¸˜é™µ", "å†»åœŸ", "ä¸›æ—",
	}
	return names[terrain]
}

// ğŸ—ï¸ å»ºç­‘ç±»å‹è½¬å­—ç¬¦ä¸²
func buildingTypeToString(building BuildingType) string {
	names := []string{
		"çºªå¿µç¢‘", "ç²®ä»“", "å›¾ä¹¦é¦†", "ç¥åº™", "å…µè¥", "åŸå¢™", "å¤§å­¦", "å·¥å‚",
	}
	return names[building]
}

// ğŸ”¬ ç§‘æŠ€ç±»å‹è½¬å­—ç¬¦ä¸²
func techTypeToString(tech TechType) string {
	names := []string{
		"å†œä¸š", "åˆ¶é™¶æœ¯", "ä¹¦å†™", "æ•°å­¦", "å»ºç­‘å­¦", "å“²å­¦", "å·¥ç¨‹å­¦", "æ•™è‚²", "ç«è¯", "å·¥ä¸šåŒ–",
	}
	return names[tech]
}

// âš”ï¸ å•ä½ç±»å‹è½¬å­—ç¬¦ä¸²
func unitTypeToString(unit UnitType) string {
	names := []string{
		"å®šå±…è€…", "æˆ˜å£«", "å¼“ç®­æ‰‹", "å‰‘å£«", "éª‘å£«", "ç«æªæ‰‹", "åŠ å†œç‚®", "å¦å…‹",
	}
	return names[unit]
}

// ğŸ›ï¸ æ–‡æ˜ç±»å‹è½¬å­—ç¬¦ä¸²
func civTypeToString(civ CivilizationType) string {
	names := []string{
		"åŸƒåŠ", "å¸Œè…Š", "ç½—é©¬", "ä¸­å›½", "æ³¢æ–¯", "å°åŠ ", "è‹±æ ¼å…°", "æ³•å›½",
	}
	return names[civ]
}

// ğŸ›ï¸ è·å–ç©å®¶ç´¢å¼•
func playerIndex(g *Game, player *Player) int {
	for i, p := range g.Players {
		if p == player {
			return i
		}
	}
	return -1
}

// ğŸ® ä¸»å‡½æ•°
func main() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("ğŸ›ï¸ æ–‡æ˜æ¸¸æˆ")
	fmt.Print("è¯·è¾“å…¥ç©å®¶æ•°é‡ (2-8): ")
	input, _ := reader.ReadString('\n')
	numPlayers, err := strconv.Atoi(strings.TrimSpace(input))
	if err != nil || numPlayers < 2 || numPlayers > 8 {
		numPlayers = 4
		fmt.Println("ä½¿ç”¨é»˜è®¤ç©å®¶æ•°é‡: 4")
	}
	game := NewGame(numPlayers)
	game.Run()
}
